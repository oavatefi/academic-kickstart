/*@@var:*/
/*
|==========================================================================================|
|                                                                                          |
|                                                                                          |
|                                         COPYRIGHT                                        |
|                                                                                          |
|                   Copyright (c) by Daimler AG Abt. RD/EEV 2015                           |
|                                                                                          |
|                                                                                          |
|==========================================================================================|
|                                                                                          |
|                                   CAPL AUTHOR IDENTITY                                   |
|                                   --------------------                                   |
|                                                                                          |
| Initials   | Name                 | Company                                              |
| -----------+----------------------+----------------------------------------------------- |
| BH         | Björn Haßelkus       | Firma TZM (EXTERN im Auftrag der Daimler AG)         |
| RS         | Rainer Schulte       | Firma TZM (EXTERN im Auftrag der Daimler AG)         |
|            |                      |                                                      |
|                                                                                          |
|==========================================================================================|
|                                                                                          |
|                                     REVISION HISTORY                                     |
|                                     ----------------                                     |
|                                                                                          |
| Date       | Ver   | Author       | Description                                          |
| -----------+-------+--------------+----------------------------------------------------- |
| 27.04.15   | 1.0   | RS           | creation                                             |
|            |       |              |                                                      |
|                                                                                          |
|------------------------------------------------------------------------------------------|
*/

variables
{
		/* DAG CAPL Include for the FlexRay Bus Control
		*
		* This include file activates/deactivates the FlexRay bus according to the called functions.
		*
		* ATTENTION:
		*   Adapt the global variables 'gFrNM1_BusName' and 'gFrNM1_Channel' accordingly to your current simulation bus!
		*   This include requires some system variables to be defined:
		*     - @sysvar::CH_NM::CH__BusState as INT with value table of tFrNM1_BUS_STATE and initially set to cFrNM1_BUS_STATE_SYNC (3)
		*   This include requires a callback function "FrNM1_RestartAfterWakeupRX()" in order to start the node simulation after a wakeup.
		*   This include file requires for proper functionality the following settings in CANoes configuration:
		*     - [Configuration | Network Configuration | FlexRay n | Options | Automatic Restart] is disabled!
		*     - [Configuration | Network Configuration | FlexRay n | Options | Send Wakeup Pattern at measurement start] is disabled!
		*     - [Configuration | Network Configuration | FlexRay n | Options | Send Wakeup Pattern at measurement start] contains valid values,
		*       e.g. set Count = 33, TxIdle = 180, TxLow = 60 and Mask = A.
		*     - [Configuration | Network Configuration | FlexRay n | Key Slot] defines *two* manual key slots with startup behavior
		*       in slots that are *not* used by any frame of the database, e.g.:
		*       - MANUAL Key Slot in slot 1 with Channel mask A as STARTUP with ALLOW LEADING COLDSTART is enabled.
		*       - MANUAL Key Slot in slot 2 with Channel mask A as STARTUP with ALLOW LEADING COLDSTART is enabled.
		*
		* Version 1.2, 2013 Vector Informatik GmbH, Department for Networks and Distributed Systems
		*/

	// General required variables (to be adapted to your simulation!):
	char    gFrNM1_BusName[256]            = "CHASSIS_FR"; // Name of bus in CANoes simulation setup
	dword   gFrNM1_Channel                 = %CHANNEL%; // The FlexRay channel the bus is attached to
	dword   gFrNM1_DebugFlags              = 0; // for setting appropriately cf. handler "on preStart" in this include file

	// Some constants:
	enum tFrNM1_POC_STATE {
		cFrNM1_POC_STATE_NOT_VALID                      = -500,
		cFrNM1_POC_STATE_SYNC_LOST                      = -2,
		cFrNM1_POC_STATE_UNKNOWN                        = -1,
		cFrNM1_POC_STATE_DEFAULT_CONFIG                 = 0,
		cFrNM1_POC_STATE_READY                          = 1,
		cFrNM1_POC_STATE_NORMAL_ACTIVE                  = 2,
		cFrNM1_POC_STATE_NORMAL_PASSIVE                 = 3,
		cFrNM1_POC_STATE_HALT                           = 4,
		cFrNM1_POC_STATE_MONITOR_MODE                   = 5,
		cFrNM1_POC_STATE_CONFIG                         = 15,
		cFrNM1_POC_STATE_WAKEUP_STANDBY                 = 16,
		cFrNM1_POC_STATE_WAKEUP_LISTEN                  = 17,
		cFrNM1_POC_STATE_WAKEUP_SEND                    = 18,
		cFrNM1_POC_STATE_WAKEUP_DETECT                  = 19,
		cFrNM1_POC_STATE_STARTUP_PREPARE                = 32,
		cFrNM1_POC_STATE_COLDSTART_LISTEN               = 33,
		cFrNM1_POC_STATE_COLDSTART_COLLISION_RESOLUTION = 34,
		cFrNM1_POC_STATE_COLDSTART_CONSISTENCY_CHECK    = 35,
		cFrNM1_POC_STATE_COLDSTART_GAP                  = 36,
		cFrNM1_POC_STATE_COLDSTART_JOIN                 = 37,
		cFrNM1_POC_STATE_INTEGRATION_COLDSTART_CHECK    = 38,
		cFrNM1_POC_STATE_INTEGRATION_LISTEN             = 39,
		cFrNM1_POC_STATE_INTEGRATION_CONSISTENCY_CHECK  = 40,
		cFrNM1_POC_STATE_INITIALIZE_SCHEDULE            = 41,
		cFrNM1_POC_STATE_ABORT_STARTUP                  = 42
	};

	enum tFrNM1_BUS_STATE {
		cFrNM1_BUS_STATE_ASYNC                          = 0,
		cFrNM1_BUS_STATE_STARTING_WITH_WAKEUP           = 1,
		cFrNM1_BUS_STATE_STARTING                       = 2,
		cFrNM1_BUS_STATE_SYNC                           = 3
	};

	const int cFrNM1_SetPOCSTATE_NONE                 = -500; // const for FrSetPOCState()
	const int cFrNM1_SetPOCSTATE_WAKEUP               = 0;    // const for FrSetPOCState()
	const int cFrNM1_SetPOCSTATE_NORMAL_ACTIVE        = 1;    // const for FrSetPOCState()
	const int cFrNM1_SetPOCSTATE_HALT                 = 2;    // const for FrSetPOCState()

	// Constants for debug output:
	const dword cFrNM1_NMIndDebug                     = 0x0001;
	const dword cFrNM1_InitDebug                      = 0x0002;
	const dword cFrNM1_NMControlDebug                 = 0x0004;
	const dword cFrNM1_BusControlDebug                = 0x0008;
	const dword cFrNM1_ILControlDebug                 = 0x0010;
	const dword cFrNM1_ShowPOCDebug                   = 0x0020;
	const dword cFrNM1_ShowSymbolDebug                = 0x0040;
	const dword cFrNM1_ShowWakeupDebug                = 0x0080;
  
	const double cFrNM1_NS2S                          = 1000000000.0;

	// Internally used variables and timers:
	int     gFrNM1_CurrentPOCstate                    = cFrNM1_POC_STATE_NOT_VALID;
	dword   gFrNM1_BusContext                         = 0; // to be initialized in "on preStart"

	// Bus control:
	int     gFrNM1_AwaitedPOCState_1                  = cFrNM1_POC_STATE_NOT_VALID;
	int     gFrNM1_DesiredNextPOCState_1_ERAY         = cFrNM1_SetPOCSTATE_NONE;
	int     gFrNM1_DesiredNextPOCState_1_COLDSTARTER  = cFrNM1_SetPOCSTATE_NONE;
	int     gFrNM1_AwaitedPOCState_2                  = cFrNM1_POC_STATE_NOT_VALID;
	int     gFrNM1_DesiredNextPOCState_2_ERAY         = cFrNM1_SetPOCSTATE_NONE;
	int     gFrNM1_DesiredNextPOCState_2_COLDSTARTER  = cFrNM1_SetPOCSTATE_NONE;
}
/*@@end*/

/*@@preStart:PreStart:*/
/*****************************************************************************
 * Include Initialization
 *****************************************************************************/

on preStart
{
	gFrNM1_BusContext = GetBusNameContext(gFrNM1_BusName);

	//gFrNM1_DebugFlags |= cFrNM1_ShowWakeupDebug;

	if (strncmp("%NODE_NAME%", "SPC", 50) == 0)
	{
//		gFrNM1_DebugFlags |= cFrNM1_NMIndDebug;
//		gFrNM1_DebugFlags |= cFrNM1_InitDebug;
//		gFrNM1_DebugFlags |= cFrNM1_NMControlDebug;
//		gFrNM1_DebugFlags |= cFrNM1_BusControlDebug;
//		gFrNM1_DebugFlags |= cFrNM1_ILControlDebug;
//		gFrNM1_DebugFlags |= cFrNM1_ShowPOCDebug;
//		gFrNM1_DebugFlags |= cFrNM1_ShowSymbolDebug;
//		gFrNM1_DebugFlags |= cFrNM1_ShowWakeupDebug;
	}
}
/*@@end*/

/*@@startStart:Start:*/
on start
{
}
/*@@end*/

/*@@caplFunc:FrNM1_StartFlexRayBus(int):*/
/*****************************************************************************
 * Bus Control
 * These functions control the bus shutdown and startup and is called
 * from within the NM simulation or the control panel.
 *****************************************************************************/

FrNM1_StartFlexRayBus(int withWakeup)
{
	if (@sysvar::CH_NM::CH__BusState == cFrNM1_BUS_STATE_ASYNC)
	{
		if (withWakeup == 0)
		{
			if (gFrNM1_DebugFlags & cFrNM1_BusControlDebug)
			{
				write("[%.6f %NODE_NAME%]: Setting POC state NORMAL_ACTIVE", TimeNowNS()/cFrNM1_NS2S);
			}
			FRSetPOCState(gFrNM1_Channel, 1, cFrNM1_SetPOCSTATE_NORMAL_ACTIVE); // E-Ray: goto NORMAL_ACTIVE
			FRSetPOCState(gFrNM1_Channel, 2, cFrNM1_SetPOCSTATE_NORMAL_ACTIVE); // Coldstarter: goto NORMAL_ACTIVE

			// Do not wait for any POC state:
			gFrNM1_AwaitedPOCState_1 = cFrNM1_POC_STATE_NOT_VALID;
			gFrNM1_DesiredNextPOCState_1_ERAY = cFrNM1_SetPOCSTATE_NONE;
			gFrNM1_DesiredNextPOCState_1_COLDSTARTER = cFrNM1_SetPOCSTATE_NONE;
			gFrNM1_AwaitedPOCState_2 = cFrNM1_POC_STATE_NOT_VALID;
			gFrNM1_DesiredNextPOCState_2_ERAY = cFrNM1_SetPOCSTATE_NONE;
			gFrNM1_DesiredNextPOCState_2_COLDSTARTER = cFrNM1_SetPOCSTATE_NONE;

			@sysvar::CH_NM::CH__BusState = cFrNM1_BUS_STATE_STARTING; // Remember that bus is already starting ...
		}
		else
		{
			if (gFrNM1_DebugFlags & cFrNM1_BusControlDebug)
			{
				write("[%.6f %NODE_NAME%]: Setting POC state WAKEUP", TimeNowNS()/cFrNM1_NS2S);
			}
			FRSetPOCState(gFrNM1_Channel, 1, cFrNM1_SetPOCSTATE_WAKEUP); // E-Ray: do potentially a WAKEUP
			// After the WAKEUP state the E-Ray returns to state READY.
			// In this state we must proceed to start the synchronization.

			// First, wait for any state during transmission of the WAKEUP pattern:
			gFrNM1_AwaitedPOCState_1 = cFrNM1_POC_STATE_WAKEUP_LISTEN; // Awaited POC state
			gFrNM1_DesiredNextPOCState_1_ERAY = cFrNM1_SetPOCSTATE_NONE;
			gFrNM1_DesiredNextPOCState_1_COLDSTARTER = cFrNM1_SetPOCSTATE_NONE;
			// Second, wait for returning to state READY and forward to NORMAL_ACTIVE:
			gFrNM1_AwaitedPOCState_2 = cFrNM1_POC_STATE_READY; // Awaited POC state
			gFrNM1_DesiredNextPOCState_2_ERAY = cFrNM1_SetPOCSTATE_NORMAL_ACTIVE;
			gFrNM1_DesiredNextPOCState_2_COLDSTARTER = cFrNM1_SetPOCSTATE_NORMAL_ACTIVE;

			@sysvar::CH_NM::CH__BusState = cFrNM1_BUS_STATE_STARTING_WITH_WAKEUP; // Remember that bus is already starting ...
		}
	}
}
/*@@end*/

/*@@caplFunc:FrNM1_StopFlexRayBus():*/
FrNM1_StopFlexRayBus()
{
	if (@sysvar::CH_NM::CH__BusState != cFrNM1_BUS_STATE_ASYNC)
	{
		if (gFrNM1_DebugFlags & cFrNM1_BusControlDebug)
		{
			write("[%.6f %NODE_NAME%]: Setting POC state HALT", TimeNowNS()/cFrNM1_NS2S);
		}
		FRSetPOCState(gFrNM1_Channel, 1, cFrNM1_SetPOCSTATE_HALT); // E-Ray: HALT
		FRSetPOCState(gFrNM1_Channel, 2, cFrNM1_SetPOCSTATE_HALT); // Coldstarter: HALT

		// Do not wait for any POC state:
		gFrNM1_AwaitedPOCState_1 = cFrNM1_POC_STATE_NOT_VALID;
		gFrNM1_AwaitedPOCState_2 = cFrNM1_POC_STATE_NOT_VALID;

		@sysvar::CH_NM::CH__BusState = cFrNM1_BUS_STATE_ASYNC; // Remember bus state
	}
}
/*@@end*/

/*@@frPocState:FlexRay PocState:*/
on FrPOCState
{
  long result1, result2;
  
	if (this.MsgChannel == gFrNM1_Channel)
	{
		if (this.FR_POCState < 254)
		{
			// This is a POC state of the E-Ray:
			gFrNM1_CurrentPOCstate = this.FR_POCState; // Remember E-Rays POC state
      
			if (gFrNM1_DebugFlags & cFrNM1_ShowPOCDebug)
			{
				write("[%.6f %NODE_NAME%]: FlexRay POC State CC%d = %2d (%s); desired = %d", TimeNowNS()/cFrNM1_NS2S, gFrNM1_CurrentPOCstate >> 8, (gFrNM1_CurrentPOCstate & 255), ((enum tFrNM1_POC_STATE)(gFrNM1_CurrentPOCstate & 255)).name(), gFrNM1_DesiredNextPOCState_1_ERAY);
			}
    
			if ((this.FR_POCState == cFrNM1_POC_STATE_NORMAL_ACTIVE) || (this.FR_POCState == cFrNM1_POC_STATE_NORMAL_PASSIVE))
			{
				@sysvar::CH_NM::CH__BusState = cFrNM1_BUS_STATE_SYNC; // Remember bus state
			}
			else if ((this.FR_POCState == cFrNM1_POC_STATE_HALT) || (this.FR_POCState == cFrNM1_POC_STATE_SYNC_LOST))
			{
				@sysvar::CH_NM::CH__BusState = cFrNM1_BUS_STATE_ASYNC; // Remember bus state
			}
		}
    
		if (this.FR_POCState == gFrNM1_AwaitedPOCState_1)
		{
			// We have waited for this POC state to be reached:
			if (gFrNM1_DebugFlags & cFrNM1_ShowPOCDebug)
			{
				write("[%.6f %NODE_NAME%]: Reached POC state %d, Setting POC state %d,%d", TimeNowNS()/cFrNM1_NS2S, gFrNM1_AwaitedPOCState_1, gFrNM1_DesiredNextPOCState_1_ERAY, gFrNM1_DesiredNextPOCState_1_COLDSTARTER);
			}

      result1 = 1;
      result2 = 1;
			// Set possibly the next POC state (if valid):
			if ((gFrNM1_DesiredNextPOCState_1_ERAY >= 0) && (gFrNM1_DesiredNextPOCState_1_ERAY <= 3))
 			{
				result1 = FrSetPOCState(gFrNM1_Channel, 1, gFrNM1_DesiredNextPOCState_1_ERAY);
        if (result1 != 1)
        {
  				write("[%.6f %NODE_NAME%]: ERROR: Setting POC E-Ray state %d", TimeNowNS()/cFrNM1_NS2S, gFrNM1_DesiredNextPOCState_1_ERAY);
        }
      }
			if ((gFrNM1_DesiredNextPOCState_1_COLDSTARTER >= 0) && (gFrNM1_DesiredNextPOCState_1_COLDSTARTER <= 3))
 			{
				result2 = FrSetPOCState(gFrNM1_Channel, 2, gFrNM1_DesiredNextPOCState_1_COLDSTARTER);
        if (result2 != 1)
        {
  				write("[%.6f %NODE_NAME%]: ERROR: Setting POC Coldstarter state %d", TimeNowNS()/cFrNM1_NS2S, gFrNM1_DesiredNextPOCState_1_COLDSTARTER);
        }
      }

      if ((result1 == 1) && (result2 == 1))
      {
			// Await second POC state next:
			gFrNM1_AwaitedPOCState_1                 = gFrNM1_AwaitedPOCState_2;
			gFrNM1_DesiredNextPOCState_1_ERAY        = gFrNM1_DesiredNextPOCState_2_ERAY;
			gFrNM1_DesiredNextPOCState_1_COLDSTARTER = gFrNM1_DesiredNextPOCState_2_COLDSTARTER;
			// Do not await any more the second POC state:
			gFrNM1_AwaitedPOCState_2                 = cFrNM1_POC_STATE_NOT_VALID;
			gFrNM1_DesiredNextPOCState_2_ERAY        = cFrNM1_SetPOCSTATE_NONE;
			gFrNM1_DesiredNextPOCState_2_COLDSTARTER = cFrNM1_SetPOCSTATE_NONE;
			}
		}

		// Show result of WAKEUP transmission/reception:
		if (this.FR_Info2 == 6)
		{
			if (gFrNM1_DebugFlags & cFrNM1_ShowWakeupDebug)
			{
				write("[%.6f %NODE_NAME%]: WAKEUP successfully transmitted", TimeNowNS()/cFrNM1_NS2S);
			}
		}
		else if ((this.FR_Info2 == 3) || (this.FR_Info2 == 4) || (this.FR_Info2 == 5))
		{
			if (gFrNM1_DebugFlags & cFrNM1_ShowWakeupDebug)
			{
				write("[%.6f %NODE_NAME%]: ERROR: WAKEUP aborted due to noise!", TimeNowNS()/cFrNM1_NS2S);
			}
		}
		else if (this.FR_Info2 == 7 /* WAKEUP RECEIVED (only with VN interface)*/)
		{
			if (gFrNM1_DebugFlags & cFrNM1_ShowWakeupDebug)
			{
				write("[%.6f %NODE_NAME%]: WAKEUP RECEIVED", TimeNowNS()/cFrNM1_NS2S);
			}
			// When we receive a wakeup pattern on FlexRay, then we also start the bus:
			FrNM1_RestartAfterWakeupRX();
		}
	}
}
/*@@end*/

/*@@frSymbol:FlexRay Symbol:*/
on FrSymbol
{
	if (this.MsgChannel == gFrNM1_Channel)
	{
		switch( this.FR_Symbol )
		{
			case 0: // Unknown
				if (gFrNM1_DebugFlags & cFrNM1_ShowSymbolDebug)
				{
					write("[%.6f %NODE_NAME%]: Symbol received: unknown", TimeNowNS()/cFrNM1_NS2S);
				}
				break;
			case 1: // CAS
				if (gFrNM1_DebugFlags & cFrNM1_ShowSymbolDebug)
				{
					write("[%.6f %NODE_NAME%]: Symbol received: CAS", TimeNowNS()/cFrNM1_NS2S);
				}
				break;
			case 2: // MTS
				if (gFrNM1_DebugFlags & cFrNM1_ShowSymbolDebug)
				{
					write("[%.6f %NODE_NAME%]: Symbol received: MTS", TimeNowNS()/cFrNM1_NS2S);
				}
				break;
			case 3: // Wakeup
				if (gFrNM1_DebugFlags & cFrNM1_ShowSymbolDebug)
				{
					write("[%.6f %NODE_NAME%]: Symbol received: Wakeup", TimeNowNS()/cFrNM1_NS2S);
				}
				FrNM1_RestartAfterWakeupRX();
				break;
			case 4: // Undefined
				if (gFrNM1_DebugFlags & cFrNM1_ShowSymbolDebug)
				{
					write("[%.6f %NODE_NAME%]: Symbol received: Length = %i", TimeNowNS()/cFrNM1_NS2S, this.FR_Length);
				}
				if (this.FR_Length >= 55)
				{
					// This is a wakeup symbol:
					FrNM1_RestartAfterWakeupRX();
				}
				break;
			default:
				if (gFrNM1_DebugFlags & cFrNM1_ShowSymbolDebug)
				{
					write("[%.6f %NODE_NAME%]: on FrSymbol: unknown item: %i", TimeNowNS()/cFrNM1_NS2S, this.FR_Symbol);
				}
				break;
		}
	}
}
/*@@end*/

/*@@caplFunc:Name:*/
/*****************************************************************************
 * EOF
 *****************************************************************************/
/*@@end*/

