/*@!Encoding:1252*/
variables
{
   
    long tm[9];
    diagRequest  Hard_Reset                                          HardReset_service;
    diagRequest Extended_Start                                       Extended_Start_service;
    int Rempark_Auth_Rs_Counter =0;
    CONST byte RESET = 0x00;
    CONST byte SET = 0x01;
    int iRet;
  // DiagGenerateKeyFromSeed 
    byte gSeedArray[8]; 
    int gSeedArraySize    = 8;
    int gSecurityLevel    = 0x01;
    char gVariant[200]    = "ParkMan_006611";
    char gOption[200]     = "option";
    byte gKeyArray[255];
    int  gMaxKeyArraySize = 255; 
    DWORD gActualSize     = 0;
  
    int  Count_Vsys_SADR_TrgrPrio_RDU = 1; 
    int  Count_Vsys_SADR_TrgrPrio_ORC = 1;
    int  Count_Vsys_SADR_TrgrPrio_ESP = 1;
    int  Count_Vsys_SADR_TrgrPrio_FCW = 1;
  
    CONST byte XCP_MODE_360DEG = 0x10;
    CONST byte XCP_MODE_MAPTEST = 0x20;
    CONST byte XCP_MODE_DOXY_SECT = 0x30;
    CONST byte XCP_MODE_CALIBRATION = 0x40;
    CONST byte XCP_MODE_UNKNOWN = 0xFF;
    CONST byte XCP_MODE_NO_DATA = 0x00;
    CONST byte XCP_MODE_ILOG = 0x80;
    CONST byte XCP_MODE_RUNTIME = 0xF0;
    CONST byte XCP_MODE_BRAKE_DATA = 0xC0;

    CONST byte XCP_DEVID_NO_XCP = 0x00;
    CONST byte XCP_DEVID_UPA_XCP = 0x01;
    CONST byte XCP_DEVID_P4U_XCP = 0x02;

    FRPDU DIAG_RQ_GLOBAL_1_FR DIAG_RQ;
    FRPDU DIAG_RQ_GLOBAL_1_FR DIAG_RQ_DEV_ID;
    
    CONST byte DEFAULT_SESSION = 0x01;
    CONST byte DEFAULT_PROGRAMMING = 0x02;
    CONST byte DEFAULT_EXTENDED = 0x03;

    byte test_start = 1;
    byte test_value;
    
    CONST byte MONITOR_FUNCTION_ACTIV = SET;
    CONST byte MONITOR_FUNCTION_DEACTIV = RESET;

    CONST byte PTS_BUTTON_PRESSED = 0x02;
    CONST byte PTS_BUTTON_RELEASED = 0x01;    

    CONST byte OFF = 0x00;
    CONST byte CONT = 0x01;

    CONST byte VOLUME_50 = 0x00;
    CONST byte VOLUME_65 = 0x01;
    CONST byte VOLUME_80 = 0x02;
    CONST byte VOLUME_100 = 0x03;

    CONST byte ROLLING_STAT_VOID = 0x00;
    CONST byte ROLLING_STAT_FORWARD = 0x01;
    CONST byte ROLLING_STAT_BACKWARD = 0x02;
    CONST byte ROLLING_STAT_SNA = 0x03;

    CONST byte TRANSMISSION_MANUAL_6 = 0x00;
    CONST byte TRANSMISSION_AUTO_5 = 0x01;
    CONST byte TRANSMISSION_AUTO_7 = 0x02;
    CONST byte TRANSMISSION_AUTO_9 = 0x03;
    CONST byte TRANSMISSION_SNA = 0x0F;

    CONST byte ECU_EIS = 0x00;
    CONST byte ECU_CPC = 0x01;
    CONST byte ECU_ESP = 0x02;
    CONST byte ECU_EPS = 0x03;
    CONST byte ECU_SCCM = 0x04;

    CONST byte ACTIVATION = 0x00;
    CONST byte DEACTIVATION = 0x01;

    CONST byte APX_Park_Stat_STROKE1 = 3;
    CONST byte APX_Park_Stat_STROKE2 = 4;
    CONST byte APX_Park_Stat_STROKE3 = 5;
    CONST byte APX_Park_Stat_STROKE4 = 6;
    CONST byte APX_Park_Stat_STROKE5 = 7;
    CONST byte APX_Brk_Stat_APX_ACTV = 4;
    CONST byte APX_Stat_APX_STEER = 6;

    CONST byte STEERING_NDEF = 0x00;
    CONST byte STEERING_LEFT = 0x01;
    CONST byte STEERING_RIGHT = 0x02;
    CONST byte STEERING_SNA = 0x03;
    float Diff_Time;
    float Time_Now;

    CONST byte GEAR_P = 0x08;
    CONST byte GEAR_R = 0x07;
    CONST byte GEAR_N = 0x06;
    CONST byte GEAR_D = 0x05; 
    CONST byte GEAR_SNA = 0x0F;

    CONST byte LIGHT_SENS_DAY = 0x00;
    CONST byte LIGHT_SENS_NIGHT = 0x01;

    CONST byte VEH_LINE_231 = 0x01;
    CONST byte VEH_LINE_212 = 0x02;
    CONST byte VEH_LINE_222 = 0x04;
    CONST byte VEH_LINE_205 = 0x06;
    CONST byte VEH_LINE_166 = 0x08;
    CONST byte VEH_LINE_217 = 0x0B;
    CONST byte VEH_LINE_213 = 0x0D;
    CONST byte VEH_LINE_218 = 0x20;
    CONST byte VEH_LINE_SNA = 0x3F;

    CONST byte IGN_STAT_KL0 = 0x00;
    CONST byte IGN_STAT_KL15C = 0x01;
    CONST byte IGN_STAT_KL15R = 0x02;
    CONST byte IGN_STAT_KL15 = 0x04;
    CONST byte IGN_STAT_KL50 = 0x05;
    CONST byte IGN_STAT_SNA = 0x07;

    CONST byte COUNTRY_GERMANY = 0x00;   
    CONST byte COUNTRY_SNA = 0xFF;

    CONST byte BODY_STYLE_FW = 0x00;
    CONST byte BODY_STYLE_FV = 0x01;
    CONST byte BODY_STYLE_FC = 0x02;
    CONST byte BODY_STYLE_FS = 0x03;
    CONST byte BODY_STYLE_FA = 0x04;
    CONST byte BODY_STYLE_FR = 0x05;
    CONST byte BODY_STYLE_FCL = 0x06;
    CONST byte BODY_STYLE_FVV = 0x07;
    CONST byte BODY_STYLE_FVF = 0x08;
    CONST byte BODY_STYLE_SNA = 0x1F;

    CONST byte EL_PARK_SYSTEM_ERR = 0x00;
    CONST byte EL_PARK_SYSTEM_NORMAL = 0x01;
    CONST byte EL_PARK_SYSTEM_DIAG = 0x02;
    CONST byte EL_PARK_SYSTEM_INIT = 0x03;
    CONST byte EL_PARK_SYSTEM_PART_OPERATION = 0x04;
    CONST byte EL_PARK_SYSTEM_PART_OPERATION_EXT = 0x05;
    CONST byte EL_PARK_SYSTEM_NDEF = 0x06;
    CONST byte EL_PARK_SYSTEM_SNA = 0x07;

    CONST byte TRAILER_NONE = 0x00;
    CONST byte TRAILER_OK = 0x01;
    CONST byte TRAILER_NDEF = 0x02;
    CONST byte TRAILER_SNA = 0x03;

    CONST byte PARK_BUTTON_NPSD = 0x00;
    CONST byte PARK_BUTTON_NDEF = 0x01;
    CONST byte PARK_BUTTON_PSD = 0x02;
    CONST byte PARK_BUTTON_SNA = 0x03;

    CONST byte ENGINE_STAT_STOP = 0x00;
    CONST byte ENGINE_STAT_START = 0x01;
    CONST byte ENGINE_STAT_IDLING_UNSTABLE = 0x02;
    CONST byte ENGINE_STAT_IDLING_STABLE = 0x03;
    CONST byte ENGINE_STAT_RUN_UNL = 0x04;
    CONST byte ENGINE_STAT_RUN_LIM = 0x05;
    CONST byte ENGINE_STAT_NDEF = 0x06;
    CONST byte ENGINE_STAT_SNA = 0x07;

    CONST float DEFAULT_IST_BAT_VOLTAGE = 12.0;
    CONST byte DEFAULT_LIGHT_SENS = LIGHT_SENS_DAY;
    CONST byte DEFAULT_ENGINE_STAT = ENGINE_STAT_IDLING_STABLE;
    CONST byte DEFAULT_EL_PARK_SYSTEM = EL_PARK_SYSTEM_ERR;
    CONST word DEFAULT_PARK_BUTTON = PARK_BUTTON_NDEF;    
    CONST word DEFAULT_SPEED = 0x00;
    CONST word DEFAULT_ODO = 0x64;
    CONST byte DEFAULT_TRAILER = TRAILER_OK;
    CONST word DEFAULT_Gear = 0x00;
    CONST word DEFAULT_Ign_Stat = IGN_STAT_KL15;    
    CONST byte DEFAULT_ROLLING_STAT_FL = ROLLING_STAT_VOID;
    CONST byte DEFAULT_ROLLING_STAT_FR = ROLLING_STAT_VOID;
    CONST byte DEFAULT_ROLLING_STAT_RL = ROLLING_STAT_VOID;
    CONST byte DEFAULT_ROLLING_STAT_RR = ROLLING_STAT_VOID;        
    /* Init-Values */
    CONST byte DEFAULT_VEH_LINE = VEH_LINE_213;
    CONST byte DEFAULT_BODY_STYLE = BODY_STYLE_FW;
    CONST byte DEFAULT_STEERING = STEERING_LEFT;
    CONST byte DEFAULT_COUNTRY = COUNTRY_GERMANY; 
    CONST byte DEFAULT_TRANSMISSION_STYLE = TRANSMISSION_AUTO_7;
    CONST byte DEFAULT_TRAILER_AVL = RESET;  
    CONST byte DEFAULT_START_STOP = RESET;

    CONST word UPDATE_TIMING = 0x64;

    CONST word TIMER_MS_ParkInfo_FR = 300;
    CONST word TIMER_MS_ROE_PARK = 500;
    CONST word TIMER_MS_BrkRqAPX_StRqAPX_FR = 500;
    CONST word TIMER_MS_DIAG_RS_PARK_FR = 2000;
    CONST word TIMER_MS_NM_PARK_AR = 500;
    CONST word TIMER_MS_XCP_Rs_VARIABLE3_FR = 100;
    CONST word TIMER_MS_XCP_Rs_RES_ERR_FR = 100;
    CONST word TIMER_MS_XCP_Rs_VARIABLE2_FR = 100;
    CONST word TIMER_MS_XCP_Rs_VARIABLE1_FR = 100;
    CONST word TIMER_MS_XCP_Rs_VARIABLE4_FR = 100;

    msTimer update_timer;
    msTimer timer_messsage_ParkInfo_FR;
    msTimer timer_messsage_ROE_PARK;
    msTimer timer_messsage_BrkRqAPX_StRqAPX_FR;
    msTimer timer_messsage_DIAG_RS_PARK_FR;
    msTimer timer_messsage_NM_PARK_AR;
    msTimer timer_messsage_XCP_Rs_VARIABLE3_FR;
    msTimer timer_messsage_XCP_Rs_RES_ERR_FR;
    msTimer timer_messsage_XCP_Rs_VARIABLE2_FR;
    msTimer timer_messsage_XCP_Rs_VARIABLE1_FR;
    msTimer timer_messsage_XCP_Rs_VARIABLE4_FR;
    msTimer default_values_timer;
    msTimer VSys_CLkS_Key_Rq_Raw_timer;
    msTimer second_start_timer;
    msTimer sleep_modus_check_timer;
    CONST word SLEEP_MODUS_CHECK_TIMING = 100;

    /* DIAG-SIM */
    byte dummy_l;
    CONST byte VDS_SUPPORTED_MSG = 7;
    CONST byte VDS_SUPPORTED_DATAS = 42;
    CONST byte VDS_DIAG_RQ_GLOBAL_1_FR = 0;
    CONST byte VDS_DIAG_RQ_GLOBAL_1_FR_SLOT = 82;
    CONST byte VDS_DIAG_RS_PARK_FR = 1;
    CONST byte VDS_DIAG_RS_PARK_FR_SLOT = 87;
    CONST byte VDS_UPDATE_TIMING = 50;                                  //in ms
    byte VDS_Datas[VDS_SUPPORTED_MSG][VDS_SUPPORTED_DATAS];
    byte VDS_Msgs[VDS_SUPPORTED_MSG];
    byte VDS_Activation[VDS_SUPPORTED_MSG];
    word VDS_Data_Timing_Value[VDS_SUPPORTED_MSG - 1];
    msTimer VDS_Update_Timer;
    msTimer VDS_Sending_Timer;
    byte VDS_Already_Init = RESET;
    byte VDS_Update_Status = RESET;
    byte VDS_Sending_Status = RESET;
    
    msTimer Auto_PTS_Timer;
    msTimer Auto_PTS_Pressed_Timer;
    word auto_pts_pressed_timing = 200;
    byte auto_pts_timer_status = 0x00;

    byte volume_change_status = RESET;    
    msTimer volume_change_timer;
    CONST word VOLUME_CHANGE_TIMEOUT = 1000;
    CONST word VOLUME_CHANGE_STATUS_READ_RQ = 0x01;
    CONST word VOLUME_CHANGE_STATUS_WRITE_RQ = 0x02;
    CONST word VOLUME_CHANGE_STATUS_WRITE_RS = 0x03;
    byte volume_change_datas[2];

    /* WHL_STATUS_SIMULATION */
    CONST word CYCLE_WHL_TIMING = 20;
    msTimer WHL_Timer;
    word whl_sim_speed;
    float whl_impluse_fl = 0x00;
    float whl_impluse_fr = 0x00;
    float whl_impluse_rl = 0x00;
    float whl_impluse_rr = 0x00;
    byte whl_sim_gearbox;
    CONST word WHL_BASIS_SPEED = 45;                    //=> 4,5km/h
    CONST float WHL_BASIS_SPEED_RPM = 13.1;             //1 km/h => 13,1 prm (RAW)
    float dummy_f = 0x00;
    byte loop;

    /* Auto XCP */
    byte RX_Brk_Rq_APX_AR = RESET;
    msTimer RX_Brk_Rq_APX_AR_Timer;
    msTimer EnvXCPStart_Stop_DAQ_RESET_Timer;
    word Brk_Rq_APX_AR_TIMEOUT = 100;
    
    /* Diagnose */
    byte VDiagData[50];
    byte VDiag_DevID_Status = RESET;

    /* To Sleep Modus */
    byte VSleep_Modus_Request = RESET;

    /* Read System-Idenfikation */
    byte VAnalyse_ID_Read_Status = 0x00;
    CONST byte VAnalyse_ID_HW_NBR = 0x01;
    CONST byte VAnalyse_ID_HW_STAND = 0x02;
    CONST byte VAnalyse_ID_SW_NBR = 0x03;
    CONST byte VAnalyse_ID_SW_STAND = 0x04;
    CONST byte VAnalyse_ID_DIAG_ID = 0x05;
    CONST byte VAnalyse_ID_BOOTSW = 0x06;
    CONST byte VAnalyse_ID_END = 0x07;
    char VDiagnose_ID_Result[20];
    char VDiagnose_dummy[3];
    byte VDiagnose_Bytes[40];

    /* VS6-Activation */
    msTimer VSys_V6_Start_Timer;
    msTimer VSys_V6_Check_Timer;
    CONST word VSys_V6_Check_Cycle = 100;
    CONST word VSYS_V6_START_TIMING = 1000;

    byte result_l;

    /* Monitoring DTC 92851C and DTC 92861C */
    msTimer VSys_MoniF_Timer;
    CONST word VSys_MoniF_Timing = 200;
    CONST byte VSys_MoniF_Number_Of_DTCs = 2;
    byte VSys_MoniF_Failure_Occur = RESET;
    dword VSys_MoniF_DTCs[VSys_MoniF_Number_Of_DTCs] = {0x92851C, 0x92861C};
    byte VSys_MoniF_DTCs_Amount[VSys_MoniF_Number_Of_DTCs] = {0x00, 0x00};    
    dword VSys_MoniF_Received_DTC = 0x00000000;
    byte VSys_MoniF_Received_DTC_Status = 0x00;
    dword VSys_MoniF_Received_Old_DTC = 0x00000000;
    byte VSys_MoniF_Received_Old_DTC_Status = 0x00;
    byte VSys_MoniF_Result = RESET;   

    /* Replay-Control */
    msTimer VRepB_Check_Timer; 
    word VRepB_Check_Timing = 10; 
    word VRepB_Check_Timing_Again_Offset = 10000;
    CONST byte REPLAYBLOCK_STATUS_STOP = 0x00;
    CONST byte REPLAYBLOCK_STATUS_START = 0x01;

    byte VAYS_Distance_RQ = RESET;
    msTimer VAYS_Distance_Timer;

    byte VSys_Start_XCP_Status = RESET;
    msTimer VSys_Start_XCP_Status_Timer;
    byte VSys_Start_XCP_Status_Timer_Timing = 10;

    byte VSys_Start_Only_XCP = RESET;

    msTimer VSys_WHL_Update;
    CONST word VSys_WHL_Update_Timing = 20;

    
   msTimer VSys_XCP_App_Car_Timer;
   msTimer VSys_XCP_App_Car_Start_Timer;
   CONST word VSYS_XCP_APP_CAR_TIMING = 20;
   CONST word VSYS_XCP_APP_CAR_START_TIMING = 2000;
   byte VSys_XCP_App_Car_Status = RESET;

    msTimer VBAT_Timer;
    msTimer VBAT_CHANGE_RESET_Timer;
    float VBAT_Voltage_Before = 0;
    byte VBAT_Status = 0;
    byte VBAT_Operation = 0;
    CONST byte VBAT_WE = 0x01;
    CONST byte VBAT_E3 = 0x02;

    CONST byte VDS_ERROR_MEMORY_DELETE_ALL = 0x01;
    CONST byte VDS_ERROR_MEMORY_DELETE_SELECTED_DTC = 0x02;
    CONST byte VDS_ERROR_MEMORY_READ_STATUS = 0x03;
    
    //
    CONST byte  KG_ENABLE_RPA = 0x01;
    CONST byte  KG_ACTIVE_RPA = 0x02;
    CONST byte  KG_LOCATE_RPA = 0x03;
    //
    CONST byte  RemPark_KG_ENABLE_RPA  = 0x03;
    CONST byte  RemPark_KG_READY_RPA   = 0x04;
    CONST byte  RemPark_KG_LOCATED_RPA = 0x05;
    //
    CONST byte  EIS_ENABLE_RPA = 0x01;
    CONST byte  EIS_START_RPA  = 0x02;
    CONST byte  EIS_ACTIVE_RPA = 0x03;
    CONST byte  EIS_LOCK_RPA   = 0x04;
    CONST byte  EIS_SNA_RPA    = 0x07;
    CONST byte  EIS_NA_RPA     = 0x00;
    //
    CONST byte  RemPark_EIS_ENABLE_RPA = 0x02;
    CONST byte  RemPark_EIS_START_RPA  = 0x03;
    CONST byte  RemPark_EIS_ACTIVE_RPA = 0x04;

    
    /*Enable Disable CPF Sim,HUPM view sync Senthil for system test automation*/
    CONST byte ENABLE = 0x01;
    CONST byte DISABLE = 0x00;

}

/*--------------------------------------------------------------------------------------------------

Erstellt: 17.03.2014        Geändert: 
Erstellt: Youssef Lamsaddar    Geändert: 
---------------------------------------------------------------------------------------------------*/
on envVar Valeo_Ist_Lenkw
{
    putValue(Valeo_Ist_Lenkw,( getSignal(EPS_FtWhlAngl_Offset)  +  getSignal(EPS_FtWhlAngl))); 
}
 
/*--------------------------------------------------------------------------------------------------
Wird ausgeführt sobald der Gang sich ändert
Erstellt: 19.04.2011        Geändert: 19.04.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on envVar VSys_Gear
{
  setSignal(TSL_Posn_Target, getValue(VSys_Gear));
  if(getValue(VSys_Gear) == 8)
  { 
    setSignal(Gr, 13); //P
    //setSignal(Gr_Target, 13); //P
  }
  else if(getValue(VSys_Gear) == 7)
  {
    setSignal(Gr, 11); //R
   // setSignal(Gr_Target, 11); //R
  }
  else if(getValue(VSys_Gear) == 6)
  {
    setSignal(Gr, 0); //N
   // setSignal(Gr_Target, 0); //N
  } 
  else if(getValue(VSys_Gear) == 5)
  {
    setSignal(Gr, 1); //D
   // setSignal(Gr_Target, 1); //D
  } 
  else
  {
    setSignal(Gr, 15); //SNA
   // setSignal(Gr_Target, 15); //SNA
  }
}
/*--------------------------------------------------------------------------------------------------
Vsys_SADR_TrgrPrio_ESP
Erstellt: 09.01.2015            Geändert:  
Erstellt: Youssef Lamsaddar     Geändert: 
---------------------------------------------------------------------------------------------------*/
 
 
void Vsys_SADR_TrgrPrio_ESP()
{  
   if(Count_Vsys_SADR_TrgrPrio_ESP < 11)
      {
        //SADR_TrgrPrio_ESP
        setSignal(SADR_TrgrPrio_ESP, 0x01); 
      }
   if(Count_Vsys_SADR_TrgrPrio_ESP > 10)
      {
        //SADR_TrgrPrio_ESP
        setSignal(SADR_TrgrPrio_ESP, 0x00); 
      }
}
/*--------------------------------------------------------------------------------------------------
Vsys_SADR_TrgrPrio_ORC
Erstellt: 09.01.2015            Geändert:  
Erstellt: Youssef Lamsaddar     Geändert: 
---------------------------------------------------------------------------------------------------*/
 
 
void Vsys_SADR_TrgrPrio_ORC()
{  
   if(Count_Vsys_SADR_TrgrPrio_ORC < 11)
      {
        //SADR_TrgrPrio_ESP
        setSignal(SADR_TrgrPrio_ORC, 0x01); 
      }
   if(Count_Vsys_SADR_TrgrPrio_ORC > 10)
      {
        //SADR_TrgrPrio_ESP
        setSignal(SADR_TrgrPrio_ORC, 0x00); 
      }
}
/*--------------------------------------------------------------------------------------------------
Vsys_SADR_TrgrPrio_RDU
Erstellt: 09.01.2015            Geändert:  
Erstellt: Youssef Lamsaddar     Geändert: 
---------------------------------------------------------------------------------------------------*/
 
 
void Vsys_SADR_TrgrPrio_RDU()
{  
   if(Count_Vsys_SADR_TrgrPrio_RDU < 11)
      {
        //SADR_TrgrPrio_ESP
        setSignal(SADR_TrgrPrio_RDU, 0x01); 
      }
   if(Count_Vsys_SADR_TrgrPrio_RDU > 10)
      {
        //SADR_TrgrPrio_ESP
        setSignal(SADR_TrgrPrio_RDU, 0x00); 
      }
}
/*--------------------------------------------------------------------------------------------------
Vsys_SADR_TrgrPrio_FCW
Erstellt: 09.01.2015            Geändert:  
Erstellt: Youssef Lamsaddar     Geändert: 
---------------------------------------------------------------------------------------------------*/
 
 
void Vsys_SADR_TrgrPrio_FCW()
{  
   if(Count_Vsys_SADR_TrgrPrio_FCW < 11)
      { 
        //SADR_TrgrPrio_FCW
        setSignal(SADR_TrgrPrio_FCW, 0x01); 
      }
   if(Count_Vsys_SADR_TrgrPrio_FCW > 10)
      { 
        //SADR_TrgrPrio_FCW
        setSignal(SADR_TrgrPrio_FCW, 0x00); 
      }
  
}
/*--------------------------------------------------------------------------------------------------
SADR_Trgr_FCW_AR2
Erstellt: 09.01.2015            Geändert:  
Erstellt: Youssef Lamsaddar     Geändert: 
---------------------------------------------------------------------------------------------------*/
 on frPDU SADR_Trgr_FCW_AR2
{
  if (getSignal(SADR_TrgrPrio_FCW)== 0x01)
    {
      Count_Vsys_SADR_TrgrPrio_FCW++; 
    }
    
}
/*--------------------------------------------------------------------------------------------------
SADR_Trgr_RDU_AR2
Erstellt: 09.01.2015            Geändert:  
Erstellt: Youssef Lamsaddar     Geändert: 
---------------------------------------------------------------------------------------------------*/
 on frPDU SADR_Trgr_RDU_AR2
{
  if (getSignal(SADR_TrgrPrio_RDU)== 0x01)
    {
      Count_Vsys_SADR_TrgrPrio_RDU++; 
    }
    
}
/*--------------------------------------------------------------------------------------------------
ORC_Impact_AR2
Erstellt: 09.01.2015            Geändert:  
Erstellt: Youssef Lamsaddar     Geändert: 
---------------------------------------------------------------------------------------------------*/
 on frPDU ORC_Impact_AR2
{
  if (getSignal(SADR_TrgrPrio_ORC)== 0x01)
    {
      Count_Vsys_SADR_TrgrPrio_ORC++; 
    }
    
}
/*--------------------------------------------------------------------------------------------------
SADR_Trgr_ESP_AR2
Erstellt: 09.01.2015            Geändert:  
Erstellt: Youssef Lamsaddar     Geändert: 
---------------------------------------------------------------------------------------------------*/
 on frPDU SADR_Trgr_ESP_AR2
{
  if (getSignal(SADR_TrgrPrio_ESP)== 0x01)
    {
      Count_Vsys_SADR_TrgrPrio_ESP++; 
    }
    
}
/*--------------------------------------------------------------------------------------------------
Default Setting
Erstellt: 19.04.2011        Geändert: 20.03.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_DefaultSetting_Without_CL15
{
   
        @sysvar::CH_NM::CH_DISPLAY_NM_WAKEUPNM = 0x01;
        setSignal(CHASSIS::EVC_CfgList_01_0C_AR2::EVC_List02_BodyStyle, BODY_STYLE_SNA); //Important: Don't delay its fix a bug from CANoe
        setSignal(CHASSIS::EVC_CfgList_01_0C_AR2::EVC_List08_Country, COUNTRY_SNA);      //Important: Don't delay its fix a bug from CANoe
     
        setSignal(ISw_Stat, IGN_STAT_KL15C);//IGN_OFF 
        @CH_Nodes::CH__EIS_ISw_Stat=IGN_STAT_KL15C;//Senthil:to sync sysvar with signal
        //Getriebe	
        //EW_08.04.2015
        setSignal(Gr_Target, 13);  // P
        setSignal(Gr, 13);  // P
        setSignal(TSL_Posn_Target, GEAR_P); // P
      
        VSys_PreInit();

        /* Activation of Old Default Values */
        putValue(Valeo_WakeAllUp, SET);
        
        cancelTimer(default_values_timer);
        setTimer(default_values_timer,200);

        putValue(VKombi_Status, SET);
        
        /*Enable Disable CPF Sim,HUPM view sync Senthil for system test automation*/
        putValue(VSys_CPFSimCtrl,ENABLE);
        putValue(VSys_HUPMViewSyncCtrl,ENABLE);
    
}

/*--------------------------------------------------------------------------------------------------
Default Setting
Erstellt: 19.04.2011        Geändert: 20.03.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_DefaultSetting_With_CL15
{
   
        @sysvar::CH_NM::CH_DISPLAY_NM_WAKEUPNM = 0x01;
        setSignal(CHASSIS::EVC_CfgList_01_0C_AR2::EVC_List02_BodyStyle, BODY_STYLE_SNA); //Important: Don't delay its fix a bug from CANoe
        setSignal(CHASSIS::EVC_CfgList_01_0C_AR2::EVC_List08_Country, COUNTRY_SNA);      //Important: Don't delay its fix a bug from CANoe
     
        setSignal(ISw_Stat, IGN_STAT_KL15);//IGN_ON
        @CH_Nodes::CH__EIS_ISw_Stat=IGN_STAT_KL15;//Senthil:to sync sysvar with signal
      
        //Getriebe	
        setSignal(Gr_Target, 11); // R
        setSignal(Gr, 11); // R
        setSignal(TSL_Posn_Target, GEAR_R); // R
        
        VSys_PreInit();

        /* Activation of Old Default Values */
        putValue(Valeo_WakeAllUp, SET);
        
        cancelTimer(default_values_timer);
        setTimer(default_values_timer,200);

        putValue(VKombi_Status, SET);
        
        /*Enable Disable CPF Sim,HUPM view sync Senthil for system test automation*/
        putValue(VSys_CPFSimCtrl,ENABLE);
        putValue(VSys_HUPMViewSyncCtrl,ENABLE);
  

  
}
/*--------------------------------------------------------------------------------------------------
Start timer for Gr delay
Erstellt: 13.11.2014        Geändert:  
Erstellt: Y Lamsaddar       Geändert:  
---------------------------------------------------------------------------------------------------*/
on signal TSL_Posn_Target
{
      /* WHL_STATUS_SIMULATION */
    if(getValue(VSys_WHL_Status) == SET)
    {
        whl_sim_gearbox = getsignal(TSL_Posn_Target);
    }
      Time_Now = timeNow() ;

   if(getSignal(TSL_Posn_Target) == 8)
  { 
   
    setSignal(Gr_Target, 13); //P
  }
  else if(getSignal(TSL_Posn_Target) == 7)
  {
    
    setSignal(Gr_Target, 11); //R
  }
  else if(getSignal(TSL_Posn_Target) == 6)
  {
     
    setSignal(Gr_Target, 0); //N
  } 
  else if(getSignal(TSL_Posn_Target) == 5)
  {
     
    setSignal(Gr_Target, 1); //D
  } 
  else
  {
     
    setSignal(Gr_Target, 15); //SNA
  }
}
/*--------------------------------------------------------------------------------------------------
TurnInd_Rq_RemPark
Erstellt: 29.09.2019        Geändert:  
Erstellt: Y Lamsaddar       Geändert:  
---------------------------------------------------------------------------------------------------*/
on signal TurnInd_Rq_RemPark
{
  switch(getSignal(TurnInd_Rq_RemPark))
  {
               case 0:
                   setSignal(TurnInd_Lt_On, 0x00); 
                   setSignal(TurnInd_Rt_On, 0x00);  
                   break;
               case 1:
                   setSignal(TurnInd_Lt_On, 0x01); 
                   setSignal(TurnInd_Rt_On, 0x00);  
                   break;
               case 2:
                   setSignal(TurnInd_Lt_On, 0x00); 
                   setSignal(TurnInd_Rt_On, 0x01);  
                   break;
               case 3:
                   setSignal(TurnInd_Lt_On, 0x00); 
                   setSignal(TurnInd_Rt_On, 0x00);  
                   break;
  }
}
/*--------------------------------------------------------------------------------------------------
Start timer for Gr delay
Erstellt: 13.11.2014        Geändert:  
Erstellt: Y Lamsaddar       Geändert:  
---------------------------------------------------------------------------------------------------*/
on signal PARK_TxDrvPosn_Rq
{
  if(getValue(VSys_Automatic_Gear_Change)==1)  
  {
    //  4=P 5=D 6=N 7=R. gear on VS6
    switch(getsignal(PARK_TxDrvPosn_Rq))
    {
          case 5:
               setSignal(TSL_Posn_Target, 0x05); // D
               @sysvar::Vsys_CH_CPCTSL_Posn_Targ =0x05;
                break;
          case 6:
               setSignal(TSL_Posn_Target, 0x06); // N
               @sysvar::Vsys_CH_CPCTSL_Posn_Targ =0x06;
                break;
          case 7:
               setSignal(TSL_Posn_Target, 0x07); // R
              @sysvar::Vsys_CH_CPCTSL_Posn_Targ = 0x07;
                break;
          case 8:
               setSignal(TSL_Posn_Target, 0x08); // P
               @sysvar::Vsys_CH_CPCTSL_Posn_Targ =0x04;
                break;
           case 0:
               setSignal(TSL_Posn_Target, 0x08); // P
               @sysvar::Vsys_CH_CPCTSL_Posn_Targ =0x04;
                break;
    }
  }
}
/*--------------------------------------------------------------------------------------------------
update Gr and Gr_Target signal from TSL_Posn_Target but with delay 
Erstellt: 15.07.2015        Geändert:  
Erstellt: Y Lamsaddar       Geändert:  
---------------------------------------------------------------------------------------------------*/

VSys_System_Updater ()
{

      getLocalTime(tm);

      setSignal(DateTmDay,tm[3]);
      setSignal(DateTmHour ,tm[2]);
      setSignal(DateTmMinute ,tm[1]);
      setSignal(DateTmMonth ,(tm[4]+1));
      setSignal(DateTmSecond ,tm[0]);
      setSignal(DateTmStat ,1);
      setSignal(DateTmYear ,(tm[5]-100 )); 

    Diff_Time = (timeNow()-Time_Now)/100 ;
  if (Diff_Time > getvalue(VSys_Gear_GR_TSL_Posn_Target))
    {
      putValue(VSys_Gear, getSignal(TSL_Posn_Target));
    }
  if(getvalue(Vsys_SADR_TrgrPrio_FCW) == 0x01)
    {
      Vsys_SADR_TrgrPrio_FCW();
    }
  else
    {
       Count_Vsys_SADR_TrgrPrio_FCW = 1;
    }
  if(getvalue(Vsys_SADR_TrgrPrio_RDU) == 0x01)
    {
      Vsys_SADR_TrgrPrio_RDU();
    }
  else
    {
       Count_Vsys_SADR_TrgrPrio_RDU = 1;
    }
  if(getvalue(Vsys_SADR_TrgrPrio_ORC) == 0x01)
    {
      Vsys_SADR_TrgrPrio_ORC();
    }
  else
    {
       Count_Vsys_SADR_TrgrPrio_ORC = 1;
    }
  if(getvalue(Vsys_SADR_TrgrPrio_ESP) == 0x01)
    {
      Vsys_SADR_TrgrPrio_ESP();
    }
  else 
    {
       Count_Vsys_SADR_TrgrPrio_ESP = 1;
    }
          //SADR_TrgrTm_ESP
        setSignal(SADR_TrgrTm_ESP, getSignal(ClockSync_Second48));
        //SADR_TrgrTm_FCW
        setSignal(SADR_TrgrTm_FCW, getSignal(ClockSync_Second48));
        //SADR_TrgrTm_ORC
        setSignal(SADR_TrgrTm_ORC, getSignal(ClockSync_Second48));
        //SADR_TrgrTm_RDU
         setSignal(SDTR::SADR_Trgr_RDU_AR2::SADR_TrgrTm_RDU, getSignal(ClockSync_Second48));
}

/*--------------------------------------------------------------------------------------------------
Set the Default Settings
Erstellt: 20.04.2011        Geändert: 20.03.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on start
{ 
    /* Init Diagnose_Sim */
    VDS_Init_At_Start();
    putValue(VSys_Sig_RemPark_Auth_Rs,0x02);
    /* DevIDs = "UNKNOWN" */ 
    putValue(VSys_DevID_Status, 0x03);
  
    putValue(VSys_SQC_Jump_CTRL_L_Stat, 0x01);  
  
    putValue(VSys_SQC_Jump_CTRL_L2_Stat, 0x01);  
  
    putValue(VSys_SQC_Jump_EVC_CfgBit_97, 0x01);  
  
    putValue(VSys_SQC_Jump_Ign_Stat, 0x01);  
  
    putValue(VSys_SQC_Jump_PARK_St_Rs, 0x01);  
  
    putValue(VSys_SQC_Jump_STA_Rs1_Pr2, 0x01);  
  
    putValue(VSys_SQC_Jump_TCM_Data2, 0x01);  
  
    putValue(VSys_SQC_Jump_VehSpd_X, 0x01);  
  
   @sysvar::CH_NM::CH_DISPLAY_NM_WAKEUPNM = 0x01;
  
    putValue(Valeo_WakeAllUp, RESET);
    setTimer(WHL_Timer, CYCLE_WHL_TIMING);

    VSys_System_Updater();    

    cancelTimer(update_timer);
    setTimer(update_timer, UPDATE_TIMING);

    cancelTimer(timer_messsage_ParkInfo_FR);
    setTimer(timer_messsage_ParkInfo_FR, TIMER_MS_ParkInfo_FR);

    cancelTimer(second_start_timer);
    setTimer(second_start_timer, 10);
    
    cancelTimer(sleep_modus_check_timer);
    setTimer(sleep_modus_check_timer, SLEEP_MODUS_CHECK_TIMING);

    putValue(Valeo_VS6switch, RESET);

    putValue(VSys_VS6_Status, RESET);
    cancelTimer(VSys_V6_Start_Timer);
    cancelTimer(VSys_V6_Check_Timer);

    putValue(VDS_Status_String, "");
    putValue(VDS_Sim_Start, RESET);

    putValue(VSys_Gear_GR_TSL_Posn_Target, 0x5DC);
    /* Monitoring Function */
    if(getValue(VSys_MoniF_Active) == SET)
    {
        cancelTimer(VSys_MoniF_Timer);
        setTimer(VSys_MoniF_Timer, VSys_MoniF_Timing);
    }
    putValue(VSys_MoniF_Amount, 0); 

//    /* Check if Replayblock is available */
//    if(ReplayStart("Replay1") == 1)
//    {
//      //  putValue(VRepB_Status_Text, "Ready to Replay");
//        ReplayStop("Replay1");
//    }
//    else
//        // putValue(VRepB_Status_Text, "No Replay-Block,Replay1");
   // putValue(VRepB_Status, RESET);

    setTimer(VSys_WHL_Update, VSys_WHL_Update_Timing);

    setTimer(VSys_XCP_App_Car_Timer, VSYS_XCP_APP_CAR_TIMING);
    VSys_Optimize (0x00);
}

/*--------------------------------------------------------------------------------------------------
Timer for the Update of Valeo_System_Sim-Panel
Erstellt: 20.04.2011        Geändert: 06.02.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer update_timer
{
    cancelTimer(update_timer);

    VSys_System_Updater();
    
    VSys_Auto_XCP_Manager();

    if(getValue(VSys_VDT_Active) == RESET)
    {
        if(DiagGetTesterPresentState() == SET)
            putValue(VSys_TesterPresent_Status, SET);
        else
            putValue(VSys_TesterPresent_Status, RESET);
    }    

    setTimer(update_timer, UPDATE_TIMING);

    if(VSleep_Modus_Request == SET)
    {
        VSys_Optimize (0x01);
        VSleep_Modus_Request =  RESET;
        putValue(Valeo_WakeAllUp, RESET);
        putValue(VKombi_Status, RESET);
        putValue(VSys_TesterPresent_Status, RESET);
        if(getValue(VSys_VDT_Active) == RESET)
        {
            DiagStopTesterPresent();
        }
    }
}

/*--------------------------------------------------------------------------------------------------
Initialition at Messurement-Start
Erstellt: 23.05.2011        Geändert: 20.03.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_Set_Init_Vales()
{
    setSignal(CHASSIS::EVC_List0C_VehLine, DEFAULT_VEH_LINE);
    setSignal(CHASSIS::EVC_CfgList_01_0C_AR2::EVC_List02_BodyStyle, BODY_STYLE_FW); 
    setSignal(CHASSIS::EVC_List01_StStyle,DEFAULT_STEERING);
    setSignal(CHASSIS::EVC_List08_Country,DEFAULT_COUNTRY);
    setSignal(CHASSIS::EVC_List05_TxStyle,DEFAULT_TRANSMISSION_STYLE);
    setSignal(CHASSIS::EVC_0F_TrlrHtch_Avl,0x00);
    setSignal(CHASSIS::EVC_26_SSA_Avl,DEFAULT_START_STOP);
    setSignal(CHASSIS::EVC_CfgBit_01_32_Stat, 0x01);
    setSignal(EPS_FtWhlAngl_Offset, 0x80);
    setSignal(EPS_FtWhlAngl_Stat, 0x01);
    setSignal(EPS_FtWhlAngl, 0x00);  
    setSignal( EVC_CfgBit_01_32_Stat , 0x01);
    setSignal(EVC_CfgBit_65_96_Stat  , 0x01);
    setSignal( EVC_CfgList_01_0C_Stat , 0x01);
}

on frFrame ParkInfo_FR2
{
    if(this.DIR == RX)
    {
        /* Zurücksetzen Timer */
        putValue(VSys_Msg_ParkInfo_FR, SET);

        /* Timer zurücksetzen */
        cancelTimer(timer_messsage_ParkInfo_FR);
        setTimer(timer_messsage_ParkInfo_FR, TIMER_MS_ParkInfo_FR);
    }
}
/*--------------------------------------------------------------------------------------------------
on signal change of EIS_RemPark_Rq  update ISw_Stat,PT_Rdy_V2
Erstellt: 24.11.2014            Geändert:  
Erstellt: Youssef Lamsaddar     Geändert: 
---------------------------------------------------------------------------------------------------*/ 
// MASE for parkout
on signal EIS_RemPark_Rq
{
  if(getValue(VSys_RPA_PARK_Out))
  {
      if(getSignal(EIS_RemPark_Rq)==2)
      {
        SetSignal(ISw_Stat, IGN_STAT_KL15);
        setSignal(PT_Rdy_V2,0x01);//I_C02_PT_RDY_PT_RDY 
      }
  
  }
}
/*--------------------------------------------------------------------------------------------------
DrRLtch_FL_Stat
Erstellt: 09.02.2014            Geändert:
Erstellt: Youssef Lamsaddar     Geändert: 
---------------------------------------------------------------------------------------------------*/
on signal DrRLtch_FL_Stat
{
    if(getValue(VSys_RPA_PARK_Out))
  {
     if (getsignal(DrRLtch_FL_Stat)==0x01)
      {
        setSignal(ISw_Stat, IGN_STAT_KL15C);        //IGN_OFF 
        setSignal(PT_Rdy_V2,0x00);                 //I_C02_PT_RDY_PT_Not_RDY 
      }
  }

}
/*--------------------------------------------------------------------------------------------------
Timer for Message RemPark_Rq_AR2
Erstellt: 04.04.2014            Geändert:26.11.2014  
Erstellt: Youssef Lamsaddar     Geändert: 
---------------------------------------------------------------------------------------------------*/
on envVar VSys_Rempark_Auth_Rs
{
  if(@VSys_Rempark_Auth_Rs==0)
  {
    putValue(VSys_Sig_RemPark_Auth_Rs,0x02);
  }
  setSignal(RemPark_Auth_Rs,0x02);
}

on frPDU NM_PARK_AR // 10ms cyclic PDU
{
      if(Rempark_Auth_Rs_Counter>=1)
      {
         Rempark_Auth_Rs_Counter ++;
      }
      if(Rempark_Auth_Rs_Counter > 76)
      {
        setSignal(RemPark_Auth_Rs,0x02);
        Rempark_Auth_Rs_Counter = 0;
      }    
}

on frPDU RemPark_Rq_AR2
{
    if ((getvalue(VSys_Rempark_Auth_Rs)==0x01) )  
      {
        if(getSignal(RemPark_Auth_Rq)==0x01 && (Rempark_Auth_Rs_Counter==0))
        {   
              setSignal(RemPark_Auth_Rs,getValue(VSys_Sig_RemPark_Auth_Rs));
              Rempark_Auth_Rs_Counter=1;         
        }
      }
     else
      {
        setSignal(RemPark_Auth_Rs,getValue(VSys_Sig_RemPark_Auth_Rs)); 
      }
      
     switch (getSignal(KG_RemPark_Rq ))
            {
              case KG_ENABLE_RPA:
               setSignal(RemPark_Stat_KG, RemPark_KG_ENABLE_RPA ); 
                break; 
              case KG_ACTIVE_RPA:
						    setSignal(RemPark_Stat_KG, RemPark_KG_READY_RPA ); 
                break; 

              case KG_LOCATE_RPA:
						    setSignal(RemPark_Stat_KG, RemPark_KG_LOCATED_RPA ); 
                break; 
        
              // DAA_VDR_2618 - Added default case to RBS [SO 18/5/2015]
              default: 
                setSignal(RemPark_Stat_KG, 0x00 ); 
                break; 
              // -------------------------------------------------------


			      }
            
    switch (getSignal(EIS_RemPark_Rq))
            {
              case EIS_ENABLE_RPA:
                setSignal(RemPark_Stat_EIS , RemPark_EIS_ENABLE_RPA ); 
                break; 
              case EIS_START_RPA:
						    setSignal(RemPark_Stat_EIS , RemPark_EIS_ACTIVE_RPA ); 
                break; 

              case EIS_ACTIVE_RPA:
						    setSignal(RemPark_Stat_EIS , RemPark_EIS_ACTIVE_RPA ); 
                break;
                //mase
             case EIS_LOCK_RPA:
                setSignal(RemPark_Stat_EIS , RemPark_EIS_ENABLE_RPA ); 
                break;  
			       }

}

/*--------------------------------------------------------------------------------------------------
Timer for Message ParkInfo_FR
Erstellt: 06.05.2011        Geändert: 06.05.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer timer_messsage_ParkInfo_FR
{
    cancelTimer(timer_messsage_ParkInfo_FR);

    /* Reset Messageflag */
    putValue(VSys_Msg_ParkInfo_FR, RESET);

    setTimer(timer_messsage_ParkInfo_FR, TIMER_MS_ParkInfo_FR);
}

on frFrame ROE_PARK
{
    if(this.DIR == RX)
    {
        /* Zurücksetzen Timer */
        putValue(VSys_Msg_ROE_PARK, SET);

        /* Timer zurücksetzen */
        cancelTimer(timer_messsage_ROE_PARK);
        setTimer(timer_messsage_ROE_PARK, TIMER_MS_ROE_PARK);
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Message ROE_PARK
Erstellt: 06.05.2011        Geändert: 06.05.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer timer_messsage_ROE_PARK
{
    cancelTimer(timer_messsage_ROE_PARK);

    /* Reset Messageflag */
    putValue(VSys_Msg_ROE_PARK, RESET);

    setTimer(timer_messsage_ROE_PARK, TIMER_MS_ROE_PARK);
}

on frFrame BrkRqPARK_StRqPARK_FR2
{
    if(this.DIR == RX)
    {
        /* Zurücksetzen Timer */
        putValue(VSys_Msg_BrkRqAPX_StRqAPX_FR, SET);

        /* Timer zurücksetzen */
        cancelTimer(timer_messsage_BrkRqAPX_StRqAPX_FR);
        setTimer(timer_messsage_BrkRqAPX_StRqAPX_FR, TIMER_MS_BrkRqAPX_StRqAPX_FR);
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Message BrkRqAPX_StRqAPX_FR
Erstellt: 06.05.2011        Geändert: 06.05.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer timer_messsage_BrkRqAPX_StRqAPX_FR
{
    cancelTimer(timer_messsage_BrkRqAPX_StRqAPX_FR);

    /* Reset Messageflag */
    putValue(VSys_Msg_BrkRqAPX_StRqAPX_FR, RESET);

    setTimer(timer_messsage_BrkRqAPX_StRqAPX_FR, TIMER_MS_BrkRqAPX_StRqAPX_FR);
}

on frFrame DIAG_RS_PARK_FR
{
    if(this.DIR == RX)
    {
        if(VAYS_Distance_RQ == SET)
        {
            /* Expect Result of Distance Diagnotic Messages */
            if(
                (this.byte(0x08) == 0x62) &&
                (this.byte(0x09) == 0x02) &&
                (this.byte(0x0A) == 0x01)
              )
            {
                /* Analysis of received datas */
                putValue(VAYS_Distance_FL, this.byte(0x0B));
                putValue(VAYS_Distance_FR, this.byte(0x0C));
                putValue(VAYS_Distance_RL, this.byte(0x0D));
                putValue(VAYS_Distance_RR, this.byte(0x0E));                 
                putValue(VAYS_Distance_FL_Disp, this.byte(0x0B));
                putValue(VAYS_Distance_FR_Disp, this.byte(0x0C));
                putValue(VAYS_Distance_RL_Disp, this.byte(0x0D));
                putValue(VAYS_Distance_RR_Disp, this.byte(0x0E));

                VAYS_Distance_RQ = RESET;
                if(getValue(VAYS_Distance_Status) == SET)
                {
                    cancelTimer(VAYS_Distance_Timer);
                    setTimer(VAYS_Distance_Timer, getValue(VAYS_Distance_Cycle)); 
                }
            }
        }

        /* Zurücksetzen Timer */
        putValue(VSys_Msg_DIAG_RS_PARK_FR, SET);

        /* Timer zurücksetzen */
        cancelTimer(timer_messsage_DIAG_RS_PARK_FR);
        setTimer(timer_messsage_DIAG_RS_PARK_FR, TIMER_MS_DIAG_RS_PARK_FR);

        /* Volume Change */
        if(volume_change_status != RESET)
        {
            switch(volume_change_status)
            {
                case VOLUME_CHANGE_STATUS_READ_RQ:
                    if(
                        (this.byte(0x08) == 0x62) &&
                        (this.byte(0x09) == 0x04) &&
                        (this.byte(0x0A) == 0x12))
                    {
                        volume_change_status = VOLUME_CHANGE_STATUS_WRITE_RQ;
                        volume_change_datas[0x00] = this.byte(0x0B);
                        volume_change_datas[0x01] = this.byte(0x0C);
                        VSys_Volume_Change_Manager();
                    }
                    break;

                case VOLUME_CHANGE_STATUS_WRITE_RQ:
                    if(
                        (this.byte(0x08) == 0x6E) &&
                        (this.byte(0x09) == 0x04) &&
                        (this.byte(0x0A) == 0x12))
                    {
                        volume_change_status = VOLUME_CHANGE_STATUS_WRITE_RS;
                        VSys_Volume_Change_Manager();
                    }
                    break;
            }
        }
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Message DIAG_RS_PARK_FR
Erstellt: 06.05.2011        Geändert: 06.05.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer timer_messsage_DIAG_RS_PARK_FR
{
    cancelTimer(timer_messsage_DIAG_RS_PARK_FR);

    /* Reset Messageflag */
    putValue(VSys_Msg_DIAG_RS_PARK_FR, RESET);

    setTimer(timer_messsage_DIAG_RS_PARK_FR, TIMER_MS_DIAG_RS_PARK_FR);
}

on frFrame NM_PARK_AR
{
    if(this.DIR == RX)
    {
        /* Zurücksetzen Timer */
        putValue(VSys_Msg_NM_PARK_AR, SET);

        /* Timer zurücksetzen */
        cancelTimer(timer_messsage_NM_PARK_AR);
        setTimer(timer_messsage_NM_PARK_AR, TIMER_MS_NM_PARK_AR);
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Message NM_PARK_AR
Erstellt: 06.05.2011        Geändert: 06.05.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer timer_messsage_NM_PARK_AR
{
    cancelTimer(timer_messsage_NM_PARK_AR);

    /* Reset Messageflag */
    putValue(VSys_Msg_NM_PARK_AR, RESET);

    setTimer(timer_messsage_NM_PARK_AR, TIMER_MS_NM_PARK_AR);
}

on frFrame XCP_Rs_VARIABLE3_FR
{
    if(this.DIR == RX)
    {
        /* Zurücksetzen Timer */
        putValue(VSys_Msg_XCP_Rs_VARIABLE3_FR, SET);

        /* Timer zurücksetzen */ 
        cancelTimer(timer_messsage_XCP_Rs_VARIABLE3_FR);
        setTimer(timer_messsage_XCP_Rs_VARIABLE3_FR, TIMER_MS_XCP_Rs_VARIABLE3_FR);
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Message XCP_Rs_VARIABLE3_FR
Erstellt: 06.05.2011        Geändert: 06.05.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer timer_messsage_XCP_Rs_VARIABLE3_FR
{
    cancelTimer(timer_messsage_XCP_Rs_VARIABLE3_FR);

    /* Reset Messageflag */
    putValue(VSys_Msg_XCP_Rs_VARIABLE3_FR, RESET);

    setTimer(timer_messsage_XCP_Rs_VARIABLE3_FR, TIMER_MS_XCP_Rs_VARIABLE3_FR);
}

on frFrame XCP_Rs_RES_ERR_FR
{
    if(this.DIR == RX)
    {
        /* Zurücksetzen Timer */
        putValue(VSys_Msg_XCP_Rs_RES_ERR_FR, SET);

        /* Timer zurücksetzen */
        cancelTimer(timer_messsage_XCP_Rs_RES_ERR_FR);
        setTimer(timer_messsage_XCP_Rs_RES_ERR_FR, TIMER_MS_XCP_Rs_RES_ERR_FR);
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Message XCP_Rs_RES_ERR_FR
Erstellt: 06.05.2011        Geändert: 06.05.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer timer_messsage_XCP_Rs_RES_ERR_FR
{
    cancelTimer(timer_messsage_XCP_Rs_RES_ERR_FR);

    /* Reset Messageflag */
    putValue(VSys_Msg_XCP_Rs_RES_ERR_FR, RESET);

    setTimer(timer_messsage_XCP_Rs_RES_ERR_FR, TIMER_MS_XCP_Rs_RES_ERR_FR);
}

on frFrame XCP_Rs_VARIABLE2_FR
{
    if(this.DIR == RX)
    {
        /* Zurücksetzen Timer */
        putValue(VSys_Msg_XCP_Rs_VARIABLE2_FR, SET);

        /* Timer zurücksetzen */
        cancelTimer(timer_messsage_XCP_Rs_VARIABLE2_FR);
        setTimer(timer_messsage_XCP_Rs_VARIABLE2_FR, TIMER_MS_XCP_Rs_VARIABLE2_FR);
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Message XCP_Rs_VARIABLE2_FR
Erstellt: 06.05.2011        Geändert: 06.05.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer timer_messsage_XCP_Rs_VARIABLE2_FR
{
    cancelTimer(timer_messsage_XCP_Rs_VARIABLE2_FR);

    /* Reset Messageflag */
    putValue(VSys_Msg_XCP_Rs_VARIABLE2_FR, RESET);

    setTimer(timer_messsage_XCP_Rs_VARIABLE2_FR, TIMER_MS_XCP_Rs_VARIABLE2_FR);
}

on frFrame XCP_Rs_VARIABLE1_FR
{
    if(this.DIR == RX)
    {
        /* Zurücksetzen Timer */
        putValue(VSys_Msg_XCP_Rs_VARIABLE1_FR, SET);

        /* Timer zurücksetzen */
        cancelTimer(timer_messsage_XCP_Rs_VARIABLE1_FR);
        setTimer(timer_messsage_XCP_Rs_VARIABLE1_FR, TIMER_MS_XCP_Rs_VARIABLE1_FR);
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Message XCP_Rs_VARIABLE1_FR
Erstellt: 06.05.2011        Geändert: 06.05.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer timer_messsage_XCP_Rs_VARIABLE1_FR
{
    cancelTimer(timer_messsage_XCP_Rs_VARIABLE1_FR);

    /* Reset Messageflag */
    putValue(VSys_Msg_XCP_Rs_VARIABLE1_FR, RESET);

    setTimer(timer_messsage_XCP_Rs_VARIABLE1_FR, TIMER_MS_XCP_Rs_VARIABLE1_FR);
}

on frFrame XCP_Rs_VARIABLE4_FR
{
    if(this.DIR == RX)
    {
        /* Zurücksetzen Timer */
        putValue(VSys_Msg_XCP_Rs_VARIABLE4_FR, SET);

        /* Timer zurücksetzen */
        cancelTimer(timer_messsage_XCP_Rs_VARIABLE4_FR);
        setTimer(timer_messsage_XCP_Rs_VARIABLE4_FR, TIMER_MS_XCP_Rs_VARIABLE4_FR);
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Message XCP_Rs_VARIABLE4_FR
Erstellt: 06.05.2011        Geändert: 06.05.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer timer_messsage_XCP_Rs_VARIABLE4_FR
{
    cancelTimer(timer_messsage_XCP_Rs_VARIABLE4_FR);

    /* Reset Messageflag */
    putValue(VSys_Msg_XCP_Rs_VARIABLE4_FR, RESET);

    setTimer(timer_messsage_XCP_Rs_VARIABLE4_FR, TIMER_MS_XCP_Rs_VARIABLE4_FR);
}

/*--------------------------------------------------------------------------------------------------
Timer for Default Settings
Erstellt: 13.05.2011        Geändert: 28.06.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer default_values_timer
{
    cancelTimer(default_values_timer);    

    VSys_Set_Init_Vales();

    VSys_Set_Main_Vales(); 

    VSys_Set_Signal_Not_SNA(); 
  
    VSys_Optimize (0x00);
      if(getValue(VSys_Sleep_Modus_Button) == SET)
    {
        VSleep_Modus_Request = SET;
        SetSignal(ISw_Stat, IGN_STAT_KL0);
        VSys_Optimize (0x01);
    }
}

/*--------------------------------------------------------------------------------------------------
Set Main-Data
Erstellt: 23.05.2011        Geändert: 10.04.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_Set_Main_Vales ()
{
    /* Init Main-Parameter */
    setSignal(VehSpd_Disp, DEFAULT_SPEED);
    setSignal(Odo, DEFAULT_ODO);   
    setSignal(Trlr_Stat, 0x00);
    setSignal(ParkSw_Psd, 0x00);
    setSignal(CHASSIS::EPKB_Stat_AR2::EPkBrk_Stat, DEFAULT_EL_PARK_SYSTEM);
    setSignal(EngRun_Stat, DEFAULT_ENGINE_STAT);
    setSignal(PT_Rdy_V2, SET);
    setSignal(LgtSens_Night, DEFAULT_LIGHT_SENS);
    setSignal(PN14_SupBat_Volt, DEFAULT_IST_BAT_VOLTAGE);
    setSignal(CHASSIS::EVC_List0C_VehLine, DEFAULT_VEH_LINE);
    setSignal(WhlDir_FL_Stat,DEFAULT_ROLLING_STAT_FL);
    setSignal(WhlDir_FR_Stat,DEFAULT_ROLLING_STAT_FR);
    setSignal(WhlDir_RL_Stat,DEFAULT_ROLLING_STAT_RL);
    setSignal(WhlDir_RR_Stat,DEFAULT_ROLLING_STAT_RR);
    setSignal(EVC_26_SSA_Avl, SET);
    setSignal(CHASSIS::EPKB_Stat_AR2::PkBrk_Stat, 0x04);
    setSignal(EVC_7B_ActPKAS_Avl, SET);
    setSignal(DidA_ExtTest_Pres, SET);
  ////// CLkS_State_AR
    setSignal( AutoDrLk_Rq_Src, 0x00);
    setSignal( AutoDrLk_Stat, 0x00);
    setSignal( CLkS_DL_Stat , 0x00);
    setSignal( CLkS_Dr_FL_Stat,0x00);
    setSignal(CLkS_Dr_FR_Stat ,0x00);
    setSignal(CLkS_Dr_RL_Stat ,0x00);
    setSignal(CLkS_Dr_RR_Stat ,0x00);
    setSignal(CLkS_Dsabl , 0x00);
    setSignal(CLkS_Gas_Dr_Stat , 0x00);
    setSignal( CLkS_Key_Rq_Raw, 0x00);
    setSignal( CLkS_Lk_Stat3, 0x00);
    setSignal( CLkS_Ovruse_Prot_Actv , 0x00);
    setSignal(CLkS_TransMd_Actv  , 0x00);
    setSignal( KeyId_V2 , 0x00);
  
  
    setSignal( EVC_CfgBit_01_32_Stat , 0x01);
    setSignal(EVC_CfgBit_65_96_Stat  , 0x01);
    setSignal( EVC_CfgList_01_0C_Stat , 0x01); 
}

/*--------------------------------------------------------------------------------------------------
Make sure that all significant signals are not SNA
Erstellt: 23.05.2011        Geändert: 27.09.2011
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_Set_Signal_Not_SNA ()
{
    /* IC_BasisInfo_AR */
    setSignal(AirTemp_Outsd_Disp,30);                       //AirTemp Outsid Disp = 30 Grad
    setSignal(EngShutOffTm,1000);                           //Engine Shut-off Time = 1000 min
    //setSignal(CoronaLgt_Stat,0x00);                         //Corona Lighting State = OFF  29b_2014  nicht mehr vorhanden
    setSignal(HVAC_Vprzr_DryVnTmr_Stat,0x00);               //Vaporizer dry ventilation timer = INACTIV
    /* TCM_DATA2_AR */
   // setSignal(Gr,0x0D);                                     //Actual Gear = GR_D1
    setSignal(EngWhlTrqRatio_TCM, 50);                      //Crankshaft torque to wheel torque = 5,0
    setSignal(SSA_Enbl_Stat_TCM, 0x01);                     //SSA enabling state = Disalbe
    setSignal(TxDrvTrqAbsVal, 20000);                       //Absolute value of the transmission overall = 20000
    //EW_08.04.2015  
    //setSignal(Gr_Target, 0x01);                             //Target Gear = D1
    SetSignal(EM_BoostTrq_Rq_TCM, 50);                               //Transmission crankshaft torque loss = 5,0
    /* Ign_Veh_Stat_AR */
    setSignal(ESL_Lk_Rq, 0x00);                             //ESL Lock Request = Default
    setSignal(SPCR_Conf_EIS, 0x01);                         //Stop Coordinator Config = Hold no SBW
    setSignal(RevGr_Engg, 0x00);                            //Reverse Gear Engaged = Disengaged
    setSignal(BusFlt_PrmntActv, 0x00);                      //Bus faulty, permanent active = Kept Awake No Flt
    /* Trailer_Stat_AR */
    setSignal(BrkLmpStyle,0x01);                            //Brake lamp style = LED Det
    setSignal(TM_FogLmp_Stat,0x00);                         //Trailer module fog lamp state = State OK
    /* EIS_BC_F_Stat2_AR */
    setSignal(BeltHdOvrSw_Psd_V2, 0x00);                    //Belt Hand Over Switch pressed = NPSD
    setSignal(ServCallSw_Stat,0x00);                        //Service call switch state = NPSD
    setSignal(SOS_CallSw_Stat, 0x00);                       //SOS call switch state = NPSD
    setSignal(RoadsdCallSw_Stat, 0x00);                     //Roadside call switch state = NPSD
    setSignal(RB_R_Sw_Psd_Ft, 0x00);                        //Rear roller blind front switch pressed = NPSD
    setSignal(NV_Sw_Psd, 0x00);                             //Nigthview switch pressed = NPSD
    setSignal(SVS_Sw_Psd, 0x00);                            //SVS switch pressed = NPSD
    setSignal(HUD_Sw_Psd, 0x00);                            //HUD switch pressed = NPSD
    setSignal(HdRst_R_Rq, 0x00);                            //Head Rest Rear request = NO ACT
    setSignal(DTQ_Sw_Md, 0x00);                             //DTR+Q switch Mode = NPSD
    setSignal(LDP_Sw_Md, 0x00);                            //ALDW switch mode = NPSD
    setSignal(HU_EjectSw_Psd_CTRL_C, 0x00);                        //Eject Switch for HU Drive Pressed = NPSD
    /* EPKB_Stat_AR */
    setSignal(CHASSIS::EPKB_Stat_AR2::BatCplSw_Rq_EPKB, 0x00);                      //Battery coupling switch request = IDLE
    setSignal(CHASSIS::EPKB_Stat_AR2::TxPkPosn_Rq_EPKB, 0x00);                      //Transmission Parking position request = IDLE
    setSignal(CHASSIS::EPKB_Stat_AR2::PkBrk_Stat, 0x04);                            //Parking Brake state = Release
    setSignal(CHASSIS::EPKB_Stat_AR2::PkBrkSw_Stat, 0x02);                          //Parking Brake switch state = Release
    //setSignal(CHASSIS::EPKB_Stat_AR2::BrkTrq_Rq_EPKB, 0.5);                         //Brake torque Request = 500
    setSignal(CHASSIS::EPKB_Stat_AR2::DynBrkMd, 0x00);                              //Dynamic braking mode = IDLE
    setSignal(CHASSIS::EPKB_Stat_AR2::BrkLgt_On_Rq, 0x00);                          //Brake Light on request = OFF                      
    /* Eng_Rs_EngCtrl_AR */
    setSignal(EngTrqMaxCorrFctr, 50);                       //Correction Factor of Max. Engine = 0x00050
    setSignal(EngRPM, 500);                                 //Actual engine rpm = 500
    setSignal(EngTrq, 500);                                 //Actual engine torque = 500
    setSignal(EngStyle, 0x01);                              //Engine 
    /* LgtSens_State_AR */
    setSignal(LgtSens_Twlgt, 4);                            //Twilight state light state = 4
    setSignal(LgtSens_Night2, 0x00);                        //Light sensor detect night mode 2 = DAY
    setSignal(LgtSens_LoBm_On_Rq, 0x00);                    //Light sensor request - turn on low = IDLE
    setSignal(SunInsty_Actv, 0x00);                         //Sun intensity sensor acitve = INACTIVE
    setSignal(SunInsty_FL, 50);                             //Sun intensity FL = 5,0
    setSignal(SunInsty_FR, 60);                             //Sun intensity FR = 6,0
    setSignal(HUD_Sens_Value, 300);                         //HUD Sensor value = 300
    setSignal(HUD_Sens_Variant, 0x01);                      //HUD sensor variant
    /* PN14_Stat_AR */
    setSignal(PN14_SupBat_Curr, 20);                       //Supply battery current = 12 V
    setSignal(PN14_SupBatCutSw_Stat, 0x00);                 //Supply battery cutoff switch state = CLS
    setSignal(DPM_MdLmt_Rq, 0x02);                          //Decentral Power management mode limit = LOCAL
    setSignal(DPM_ExtMd_Enbl_Rq, 0x02);                     //Decentral power Management = EXT
    setSignal(PN14_TransMd_Stat, 0x00);                     //Powernet transport mode status = OFF
    /* EVC_CfgList_01_OC_AR */
    setSignal(EVC_CfgList_01_0C_Stat, 0x01);                //Status EVC-CfgMessageLists = PROGRAMMED
    setSignal(EVC_List03_RoofStyle, 0x00);                  //Roof Style = PANORAMAROOF
    setSignal(EVC_List04_HL_Style, 0x00);                   //HEADLAMP Style = BI XEN RHT
    setSignal(EVC_List06_VehLineYear, 2012);                //Vehicle line Version = 2012
    setSignal(EVC_List07_HVAC_Style, 0x00);                 //AIRCONDITION
    setSignal(EVC_List09_HU_Style,0x00);                    //Headunit Style = CMD APS
    setSignal(EVC_List0A_TPM_Style,0x00);                   //Tyre Pressure Monitoring Style = INFLRESSCTRL LOW
    setSignal(EVC_List0B_AddEquip, 0x00);                   //Additional Equipment List = VAR 0
    /* Whl_Lt_Stat_AR */
    setSignal(WhlRPM_FL_Qual, 0x01);                        //Quality of Wheel rpm front left = Electrical
    setSignal(WhlRPM_RL_Qual, 0x01);                        //Quality of Wheel rpm rear left = Electical
    setSignal(WhlRPM_FL, 0x00);                             //Wheel rpm front left = 0
    setSignal(Whl_Lt_Stat_AR2::WhlPlsCnt_FL, 0x00);                          //Wheel pulse counter front left = 0
    setSignal(WhlRPM_RL, 0x00);                             //Wheel rpm rear left = 0
    setSignal(Whl_Lt_Stat_AR2::WhlPlsCnt_RL, 0x00);                          //Wheel pulse counter rear left = 0
    /* WHL_Rt_Stat_AR */
    setSignal(WhlRPM_FR_Qual, 0x01);                        //Quality of Wheel rpm front right = Electrical
    setSignal(WhlRPM_RR_Qual, 0x01);                        //Quality of Wheel rpm rear right = Electrical
    setSignal(WhlRPM_FR, 0x00);                             //Wheel rpm front right = 0
    setSignal(Whl_Rt_Stat_AR2::WhlPlsCnt_FR, 0x00);                          //Wheel pulse counter front right = 0
    setSignal(WhlRPM_RR, 0x00);                             //Wheel rpm rear right
    setSignal(Whl_Rt_Stat_AR2::WhlPlsCnt_RR, 0x00);                          //Wheel pulse counter rear right = 0
    /* VehDyn_SPCR_Stat_AR */
    setSignal(VehYawRate_Raw, 0x00);                        //Yaw rate of the vehicle = 0
    /* APX_St_Rs_AR */
    //setSignal(EPS_StRackPosn, 0x00);                        //Rack position = 0
    setSignal(VehSpd_X_Qual, 0x01);                         //Norm_Oprnt
    setSignal(VehDrvDir_Stat, 0x00);                        //Void
    setSignal(VehSpd_X_Min, 0x00);                          //0km/h
    setSignal(VehSpd_X, 0x00);                              //0km/h
    setSignal(VehSpd_X_Max, 0x00);                         //4094
    setSignal(VehSp_Stat, 0x01);                            //Not_DTCT
    setSignal(STA_Stat, 0x01);                              //AVL
    setSignal(StW_Trq_EPS, 8192);                           //0
    setSignal(VehYawRateOffset_V2, 512);                    //0
    setSignal(VehYawRate_Raw_Qual, 0x02);                   //Qual_Func
    setSignal(ESP_Oprtn_Stat_AS_V2, 0x00);                  //Normal
    setSignal(PARK_Enbl_Stat_ESP, 0x01);                    //Enable APC
    setSignal(EngHd_Stat_BC_F, 0x01);                    //EngHd_Stat_BC_F 
    setSignal(DL_RLtch_Stat, 0x01);                    //DL_RLtch_Stat 
  
    /* 06-Aug-2015 (SO) : The signal below set to non SNA value to fix DTC c13287 - "Communication *
     *                    with control unit Suspension has a malfunction - Missing Message".       *
     *                    DTC was seen by Colin Harty (Tuam) following variant coding of ECU.      */
    setSignal(SPC::SPC_SwLED_Msg_Rq_AR2::SuspLvlAdjSwLED_Rq, 0x01);   
	
	/* 07-Aug-2015 (SO) : The signal below set to non SNA value to fix DTC c13286 - "Communication *
     *                    with control unit Audio or COMAND has a malfunction - Missing Message".  */
    setSignal(HU_State_AR::HU_DayNightMd_Stat, 0x00);
   //DAA_VCO_5825   
   setSignal(EF_Actv , 0x00); //
   setSignal(TurnInd_Lt_On , 0x00); //
   setSignal(TurnInd_Rt_On , 0x00); //
   setSignal(CPF_Ft_Stat , 0x00); //CPF_Ft_Stat 
   setSignal(ParkSw_Psd_CTRL_C , 0x00); //ParkSw_Psd_CTRL_C 
   setSignal(HU_On_Stat , 0x00); //ParkSw_Psd_CTRL_C 
}

/*--------------------------------------------------------------------------------------------------
Default Setting only for the Init-Values
Erstellt: 23.05.2011        Geändert: 23.05.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on envVar VSys_Smart_Default_Setting
{
    if(getValue(VSys_Smart_Default_Setting) == SET)
    {   
        /* Init-Values */
        VSys_Set_Init_Vales();
        
        /* No SNA */
        VSys_Set_Signal_Not_SNA();
    }
}

on frFrame Ign_Veh_CLkS_Stat_FR2
{

}

on frPDU TCM_Data2_AR2
{   
    dword test_time; 
    test_time = this.Time; 
    
    
    if(test_start == SET)
    {
        test_start = RESET;
    }
    else
    {
        if(this.SQC_TCM_Data2_Pr2-1 != test_value)
        {
            if(((test_value == 15) && ((byte) this.SQC_TCM_Data2_Pr2 == 0)))
            {
                test_value = this.SQC_TCM_Data2_Pr2;
            }
            else
            {
                putValue(test_led, SET);        
            }
        }
    }
    test_value = this.SQC_TCM_Data2_Pr2;

//    /* WHL_STATUS_SIMULATION */
//    if(getValue(VSys_WHL_Status) == SET)
//    {
//        whl_sim_gearbox = this.TSL_Posn_TCM;
//    }
}

on key CursorUp
{
    switch(getSignal(TSL_Posn_Target))
    {
        case 0x00:
            setSignal(TSL_Posn_Target, 0x01);
            break;
        case 0x01:
            setSignal(TSL_Posn_Target, 0x02);
            break;
        case 0x02:
            setSignal(TSL_Posn_Target, 0x04);
            break;
        case 0x04:
            setSignal(TSL_Posn_Target, 0x07);
            break;             
    }
}

on signal TurnInd_Lt_On
{
    write ("Signal %d", getSignal(TurnInd_Lt_On));
}

/*--------------------------------------------------------------------------------------------------
Aktivierungslogik-Überprüfung
Erstellt: 21.09.2011        Geändert: 30.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/
on frPDU Brk_Rq_PARK_AR2
{
    if(
        (this.PARK_Park_Stat == APX_Park_Stat_STROKE1) ||
        (this.PARK_Park_Stat == APX_Park_Stat_STROKE2) ||
        (this.PARK_Park_Stat == APX_Park_Stat_STROKE3) ||
        (this.PARK_Park_Stat == APX_Park_Stat_STROKE4) ||
        (this.PARK_Park_Stat == APX_Park_Stat_STROKE5)
      )
        putValue(VSys_Test_Activation_ACTL, SET);
    else
        putValue(VSys_Test_Activation_ACTL, RESET);

    if(this.PARK_Brk_Stat == APX_Brk_Stat_APX_ACTV)
        putValue(VSys_Test_Activation_BRKH, SET);
    else
        putValue(VSys_Test_Activation_BRKH, RESET);

    /* Auto XCP */
    cancelTimer(RX_Brk_Rq_APX_AR_Timer);
    RX_Brk_Rq_APX_AR = SET;
    setTimer(RX_Brk_Rq_APX_AR_Timer,Brk_Rq_APX_AR_TIMEOUT); 

    /* Sim Brk STAT */
//    switch(this.PARK_Brk_Stat)
//    {
//        case(0): 
//            setSignal(PARK_Brk_Stat_ESP,0);
//            @Valeo_BrakeActive = 0;
//            break;
//        case(1):
//            setSignal(PARK_Brk_Stat_ESP,1);
//            @Valeo_BrakeActive = 0;
//            break;
//        case(2):           
//            setSignal(PARK_Brk_Stat_ESP,2);
//            @Valeo_BrakeActive = 0;
//            break;
//        case(3):
//            setSignal(PARK_Brk_Stat_ESP,3);
//            @Valeo_BrakeActive = 0; 
//            break;
//        case(4):
//            setSignal(PARK_Brk_Stat_ESP,4);
//            @Valeo_BrakeActive = 0;
//            break;
//         case(5): 
//            setSignal(PARK_Brk_Stat_ESP,5);
//            @Valeo_BrakeActive = 0;
//            break;
//        case(6):
//            setSignal(PARK_Brk_Stat_ESP,6);
//            @Valeo_BrakeActive = 0;
//            break;
//        case(7):           
//            setSignal(PARK_Brk_Stat_ESP,7);
//            @Valeo_BrakeActive = 0;
//            break;
//        case(8):
//            setSignal(PARK_Brk_Stat_ESP,8);
//            @Valeo_BrakeActive = 1; // Bremse aktiv
//            break;
//        case(9):
//            setSignal(PARK_Brk_Stat_ESP,9);
//            @Valeo_BrakeActive = 0;  
//            break;
//        case(10):
//            setSignal(PARK_Brk_Stat_ESP,10);
//            @Valeo_BrakeActive = 0;
//            break;
//        case(11):
//            setSignal(PARK_Brk_Stat_ESP,11);
//            @Valeo_BrakeActive = 0;
//            break;
//        case(12):
//            setSignal(PARK_Brk_Stat_ESP,12);
//            @Valeo_BrakeActive = 0;
//            break;
//
//        case(13):
//            setSignal(PARK_Brk_Stat_ESP,13);
//            @Valeo_BrakeActive = 1;
//            break;
//        default:
//            setSignal(PARK_Brk_Stat_ESP,2);
//            @Valeo_BrakeActive = 0;
//    }
}

/*--------------------------------------------------------------------------------------------------
Aktivierungslogik-Überprüfung
Erstellt: 21.09.2011        Geändert: 21.09.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on frPDU St_Rq_PARK_AR2
{
    if(this.PARK_Stat_PARK == APX_Stat_APX_STEER)
        putValue(VSys_Test_Activation_STMH, SET);
    else
        putValue(VSys_Test_Activation_STMH, RESET);
}

/*--------------------------------------------------------------------------------------------------
Aktiviation/Deactivation of PDU EIS
Erstellt: 22.09.2011        Geändert: 22.09.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on envVar VPDU_Manager_EIS
{
    byte change_status_l = SET;;

    if(getValue(VPDU_Manager_EIS) == SET)
    {
        if(getValue(VPDU_Manager_EIS_LED) == SET)
        {
            putValue(VPDU_Manager_EIS_LED, RESET);
            VPDU_Manager(ECU_EIS, DEACTIVATION);
        }
        else
        {
            putValue(VPDU_Manager_EIS_LED, SET);
            VPDU_Manager(ECU_EIS, ACTIVATION);
        }
    }   
}

VPDU_Manager (byte ecu_p, byte change_status_p)
{
    switch(ecu_p)
    {
        case ECU_EIS:
            @CH_Nodes::CH__STPDU_EIS_ADAS_CURRENT_ATTRIBUTES_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_ADAS_POSITION_AR = change_status_p;
            //@CH_Nodes::CH__STPDU_EIS_ALDW_Disp_Warn_Rq_AR = change_status_p;
            //@CH_Nodes::CH__STPDU_EIS_ALDW_LaneAttr1_AR = change_status_p;
            //@CH_Nodes::CH__STPDU_EIS_ALDW_LaneAttr2_AR = change_status_p;
            //@CH_Nodes::CH__STPDU_EIS_ALDW_LaneAttr3_AR = change_status_p;
            //@CH_Nodes::CH__STPDU_EIS_ASM_Rq_AR = change_status_p;
        ///    @CH_Nodes::CH__STPDU_EIS_Assyst_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_BC_F_Disp_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_BC_F_Stat1_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_BC_F_Stat2_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_BC_R_Stat1_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_BLSM_Disp_Stat_AR = change_status_p;
         ///   @CH_Nodes::CH__STPDU_EIS_Brk_SPCR_Rq_RDU_Gw_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_CLkS_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_CLkS_State_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_CMS_PI_State_Gw_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_CRCM_Stat_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_CTRL_C_Stat1_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_DAC4_ECM_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_DAC4_EM2_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_DAC4_ISM_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_DAC4_TCM_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_Dimming_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_Door_FL_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_Door_FR_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_Door_RL_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_Door_RR_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_EAC_Stat_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_EL_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_EL_TurnInd_Rq_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_EPKB_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_EVC_CfgBit_01_32_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_EVC_CfgBit_33_64_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_EVC_CfgBit_65_96_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_EVC_CfgList_01_0C_AR2 = change_status_p;
            //@CH_Nodes::CH__STPDU_EIS_HLI_Lt_Ext_Lgt_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_HU_State_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_HVAC_Disp_Stat1_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_HVAC_OBD_DTC_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_HVAC_Rs2_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_HVAC_Rs_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_HVAC_State1_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_ICH_Stat_AR = change_status_p;
           // @CH_Nodes::CH__STPDU_EIS_IC_BasicInfo2_AR2 = change_status_p;
           // @CH_Nodes::CH__STPDU_EIS_IC_BasicInfo_AR2 = change_status_p;
           // @CH_Nodes::CH__STPDU_EIS_IC_Date_Time_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_IC_DriveAssistSys_AR2 = change_status_p;
            ///@CH_Nodes::CH__STPDU_EIS_IC_EnergyMngmnt_Stat_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_IC_Settings_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_IHC_Lgt_Stat_HLI_2_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_IHC_Lgt_Stat_HLI_AR2 = change_status_p;
            //@CH_Nodes::CH__STPDU_EIS_IL_Stat_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_Ign_Veh_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_LDC_Disp_Stat_IC_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_LgtSens_State_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_Mirr_Adj_Lt_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_Mirr_Adj_Rt_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_NAVI_Pos1_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_NAVI_Pos2_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_NAVI_Pos3_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_NAVI_Pos4_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_NAVI_Pos5_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_NVP_Stat1_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_ORC_Disp_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_ORC_Impact_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_PN14_Rs1_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_PN14_Rs2_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_PN14_Stat_AR = change_status_p;
          ///  @CH_Nodes::CH__STPDU_EIS_PT_Rq_RDU_Gw_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_Park_Disp_Rs_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_PreCond_On_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_PreCond_Stat_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_SPCR_Stat_BC_F_AR2 = change_status_p;
            ///@CH_Nodes::CH__STPDU_EIS_SPL_Obj1_Obj2_NV_AR2 = change_status_p;
            ///@CH_Nodes::CH__STPDU_EIS_SPV_Actn_Rq_AR = change_status_p;
            ///@CH_Nodes::CH__STPDU_EIS_SPV_Alm_Rq_AR = change_status_p;
           /// @CH_Nodes::CH__STPDU_EIS_SPV_Stat_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_SVS_Rq_HU_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_SeatAdj_FL_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_SeatAdj_FR_Rq_AR = change_status_p;
            //@CH_Nodes::CH__STPDU_EIS_TBCC_Req_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_TSA_Disp_Rq1_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_TSA_Disp_Rq2_AR = change_status_p;
            ///@CH_Nodes::CH__STPDU_EIS_Tire_State_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_TrafficInfo_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_Trailer_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_VIN_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_WUDOP_EIS_FR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_Wiper_Stat_AR = change_status_p;
            //@CH_Nodes::CH__STPDU_EIS_XCP_Rs_RES_ERR_FR = change_status_p;
            /*todo @CH_Nodes::CH__STPDU_EIS_XCP_Rs_VARIABLE1_FR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_XCP_Rs_VARIABLE2_FR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_XCP_Rs_VARIABLE3_FR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_XCP_Rs_VARIABLE4_FR = change_status_p;
            @CH_Nodes::CH__STPDU_EIS_XCP_Rs_VARIABLE5_FR = change_status_p;*/
            break;
        case ECU_CPC:
            @CH_Nodes::CH__STPDU_CPC_HumanMachineIfc_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_Adblue_Disp_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_Adblue_Disp_Warn_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_Assyst_Stat2_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_Assyst_Stat_AR = change_status_p;
          ///  @CH_Nodes::CH__STPDU_CPC_DCDC1_Rs_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_ECM_DAC4_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_ECO_Score_Disp_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_EM01_Stat1_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_EM01_Stat2_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_EM01_Trq_Rs_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_EM_DAC4_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_ESP_OBD_Data_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_EnergyMngmnt_PreCond_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_EngCtrl_Disp_Rq_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_EngCtrl_OBD1_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_EngCtrl_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_Eng_Rs_1_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_Eng_Rs_2_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_Eng_Rs_3_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_Eng_Rs_EM_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_Eng_Rs_EngCtrl_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_Fuel_Stat2_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_FuelLvl_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_HumanMachineIfc_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_ISM_DAC4_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_OBL_DC_Output_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_PN14_Gen_Rs_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_PNHV_EnergyMngmntSet_Rs1_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_PNHV_EnergyMngmntSet_Rs2_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_PNHV_EnergyMngmnt_Stat2_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_PNHV_EnergyMngmnt_Stat3_AR2 = change_status_p;
           /// @CH_Nodes::CH__STPDU_CPC_PNHV_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_PNHV_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_PT_ThermM_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_PtHyb_Mngmnt_Rq1_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_PtMngmnt_Disp_Rq_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_PtMngmnt_Rq_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_PtMngmnt_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_SBW_DrvPosn_Disp_Rq_ISM_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_SBW_DrvPosn_Disp_Rq_TCM_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_SBW_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_TCM_DAC4_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_TCM_Data2_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_TCM_Data3_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_TCM_State3_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_TC_EBBC_Disp_Rq_ECM_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_ThermMngmnt_1_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_ThermMngmnt_4_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_VehPwrMngmnt_EMM_Stat2_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_VehPwrMngmnt_Rq_AR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_WIA_EngTrq_AR = change_status_p;
            //@CH_Nodes::CH__STPDU_CPC_XCP_Rs_RES_ERR_FR = change_status_p;
            /*todo @CH_Nodes::CH__STPDU_CPC_XCP_Rs_VARIABLE1_FR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_XCP_Rs_VARIABLE2_FR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_XCP_Rs_VARIABLE3_FR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_XCP_Rs_VARIABLE4_FR = change_status_p;
            @CH_Nodes::CH__STPDU_CPC_XCP_Rs_VARIABLE5_FR = change_status_p;*/
            break;
        case ECU_ESP:
            @CH_Nodes::CH__STPDU_ESP_PARK_Brk_Rs_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_BrkSys_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_ESP_Disp_Rq2_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_ESP_Disp_Rq_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_ESP_OBD_Stat_AR = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_Eng_Susp_Rq_AS_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_LDC_Disp_Rq_ESP_AR = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_PT_Rq_ESP_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_PresfCtrl_Rq_ESP_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_ROE_ESP = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_St_Rq_STA_AR2 = change_status_p;
            //@CH_Nodes::CH__STPDU_ESP_TBCC_Resp_AR = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_VehDyn_Stat1_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_VehDyn_Stat2_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_WUDOP_ESP_FR = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_Whl_Lt_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_Whl_Rt_Stat_AR2 = change_status_p;
            //@CH_Nodes::CH__STPDU_ESP_XCP_Rs_RES_ERR_FR = change_status_p;
            /*todo @CH_Nodes::CH__STPDU_ESP_XCP_Rs_VARIABLE1_FR = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_XCP_Rs_VARIABLE2_FR = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_XCP_Rs_VARIABLE3_FR = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_XCP_Rs_VARIABLE4_FR = change_status_p;
            @CH_Nodes::CH__STPDU_ESP_XCP_Rs_VARIABLE5_FR = change_status_p;*/
            @CH_Nodes::CH__STPDU_ESP_YMAS_Rs_AR2 = change_status_p;
            break;
        case ECU_EPS:
            @CH_Nodes::CH__STPDU_EPS_PARK_St_Rs_AR2 = change_status_p;
            //@CH_Nodes::CH__STPDU_EPS_ASM_Resp_AR = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_DTQ_Rs_AR2 = change_status_p;
            //@CH_Nodes::CH__STPDU_EPS_ECU_APPL_EPS1 = change_status_p;
            //@CH_Nodes::CH__STPDU_EPS_ECU_APPL_EPS2 = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_EPS_Stat_Disp_Rq_AR2 = change_status_p;
            /*todo @CH_Nodes::CH__STPDU_EPS_Meas_EPS_1 = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_Meas_EPS_2 = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_Meas_EPS_3 = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_Meas_EPS_4 = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_Meas_EPS_5 = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_Meas_EPS_6 = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_Meas_EPS_7 = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_Meas_EPS_8 = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_Meas_EPS_9 = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_Meas_EPS_A = change_status_p;*/
            @CH_Nodes::CH__STPDU_EPS_ROE_EPS = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_STA_Rs1_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_WUDOP_EPS_FR = change_status_p;
            //@CH_Nodes::CH__STPDU_EPS_XCP_Rs_RES_ERR_FR = change_status_p;
            /*todo @CH_Nodes::CH__STPDU_EPS_XCP_Rs_VARIABLE1_FR = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_XCP_Rs_VARIABLE2_FR = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_XCP_Rs_VARIABLE3_FR = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_XCP_Rs_VARIABLE4_FR = change_status_p;
            @CH_Nodes::CH__STPDU_EPS_XCP_Rs_VARIABLE5_FR = change_status_p;*/
            break;
        case ECU_SCCM: 
            /*todo @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM1 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM2 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM3 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM4 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM5 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM6 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM7 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM8 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM9 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCMA = change_status_p;*/
            @CH_Nodes::CH__STPDU_SCCM_LDC_SBW_Rq_SCCM_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_ROE_SCCM = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_SCCM_Sw_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_StWhl_Angl_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_StWhl_Sw_Stat_AR2 = change_status_p;
            @CH_Nodes::CH__STPDU_SCCM_WUDOP_SCCM_FR = change_status_p;
            break;
    }
}

/*--------------------------------------------------------------------------------------------------
Aktiviation/Deactivation of PDU CPC
Erstellt: 22.09.2011        Geändert: 22.09.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on envVar VPDU_Manager_CPC
{
    byte change_status_l = SET;;

    if(getValue(VPDU_Manager_CPC) == SET)
    {
        if(getValue(VPDU_Manager_CPC_LED) == SET)
        {
            putValue(VPDU_Manager_CPC_LED, RESET);
            VPDU_Manager(ECU_CPC, DEACTIVATION);
        }
        else
        {
            putValue(VPDU_Manager_CPC_LED, SET);
            VPDU_Manager(ECU_CPC, ACTIVATION);
        }
    }   
}

/*--------------------------------------------------------------------------------------------------
Aktiviation/Deactivation of PDU EPS
Erstellt: 22.09.2011        Geändert: 22.09.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on envVar VPDU_Manager_EPS
{
    byte change_status_l = SET;;

    if(getValue(VPDU_Manager_EPS) == SET)
    {
        if(getValue(VPDU_Manager_EPS_LED) == SET)
        {
            putValue(VPDU_Manager_EPS_LED, RESET);
            VPDU_Manager(ECU_EPS, DEACTIVATION);
        }
        else
        {
            putValue(VPDU_Manager_EPS_LED, SET);
            VPDU_Manager(ECU_EPS, ACTIVATION);
        }
    }   
}

/*--------------------------------------------------------------------------------------------------
Aktiviation/Deactivation of PDU ESP
Erstellt: 22.09.2011        Geändert: 22.09.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on envVar VPDU_Manager_ESP
{
    byte change_status_l = SET;;

    if(getValue(VPDU_Manager_ESP) == SET)
    {
        if(getValue(VPDU_Manager_ESP_LED) == SET)
        {
            putValue(VPDU_Manager_ESP_LED, RESET);
            VPDU_Manager(ECU_ESP, DEACTIVATION);
        }
        else
        {
            putValue(VPDU_Manager_ESP_LED, SET);
            VPDU_Manager(ECU_ESP, ACTIVATION);
        }
    }   
}

/*--------------------------------------------------------------------------------------------------
Aktiviation/Deactivation of PDU SCCM
Erstellt: 22.09.2011        Geändert: 22.09.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on envVar VPDU_Manager_SCCM
{
    byte change_status_l = SET;;

    if(getValue(VPDU_Manager_SCCM) == SET)
    {
        if(getValue(VPDU_Manager_SCCM_LED) == SET)
        {
            putValue(VPDU_Manager_SCCM_LED, RESET);
            VPDU_Manager(ECU_SCCM, DEACTIVATION);
        }
        else
        {
            putValue(VPDU_Manager_SCCM_LED, SET);
            VPDU_Manager(ECU_SCCM, ACTIVATION);
        }
    }   
}

on preStop
{
    /* Activate all ECUs */
    VPDU_Manager(ECU_EIS, ACTIVATION);
    VPDU_Manager(ECU_CPC, ACTIVATION);
    VPDU_Manager(ECU_ESP, ACTIVATION);
    VPDU_Manager(ECU_EPS, ACTIVATION);
    VPDU_Manager(ECU_SCCM, ACTIVATION);

    putValue(VPDU_Manager_EIS_LED, SET);
    putValue(VPDU_Manager_CPC_LED, SET);
    putValue(VPDU_Manager_EPS_LED, SET);
    putValue(VPDU_Manager_ESP_LED, SET);
    putValue(VPDU_Manager_SCCM_LED, SET);
}

/*--------------------------------------------------------------------------------------------------
Close all open Panels
Erstellt: 17.11.2011        Geändert: 17.11.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on envVar VSys_Close_All_Panels
{
    if(getValue(VSys_Close_All_Panels) == SET) 
    {
        closePanel("Valeo_Init_Data");
        closePanel("XCP_DAQ");
        closePanel("VS6");
        closePanel("Valeo_Extended_Data");
        closePanel("PDU Manager");
        closePanel("CHASSIS_FR Netzmanagement");
        closePanel("CHASSIS_FR PDU Stopp Panel");
    }
}

/*--------------------------------------------------------------------------------------------------
Activation/Deactivation for Optimization PDUs
Erstellt: 17.11.2011        Geändert: 17.11.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on envVar VSys_Optimize_PDU
{
    if(getValue(VSys_Optimize_PDU) == SET)
    {
        if(getValue(VSys_Optimize_PDU_LED) == SET)
        {
            //Deactivation of Optimization
            putValue(VSys_Optimize_PDU_LED, RESET);
            VSys_Optimize(ACTIVATION);
        }
        else
        {
            //Activation of Optimization
            putValue(VSys_Optimize_PDU_LED, SET);
            VSys_Optimize(DEACTIVATION);
        }
    }   
}

/*--------------------------------------------------------------------------------------------------
Optimization of PDUs
Erstellt: 17.11.2011        Geändert: 09.05.2012
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

VSys_Optimize (byte change_status_p)
{
    //EIS
    @CH_Nodes::CH__STPDU_EIS_ADAS_CURRENT_ATTRIBUTES_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_ADAS_POSITION_AR = change_status_p;
    //@CH_Nodes::CH__STPDU_EIS_ALDW_Disp_Warn_Rq_AR = change_status_p;
    //@CH_Nodes::CH__STPDU_EIS_ALDW_LaneAttr1_AR = change_status_p;
    //@CH_Nodes::CH__STPDU_EIS_ALDW_LaneAttr2_AR = change_status_p;
    //@CH_Nodes::CH__STPDU_EIS_ALDW_LaneAttr3_AR = change_status_p;
    //@CH_Nodes::CH__STPDU_EIS_ASM_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_Assyst_Rq_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_BC_F_Disp_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_BC_F_Stat1_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_BLSM_Disp_Stat_AR = change_status_p;
   //// @CH_Nodes::CH__STPDU_EIS_Brk_SPCR_Rq_RDU_Gw_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_CLkS_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_CLkS_State_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_CMS_PI_State_Gw_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_CRCM_Stat_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_CTRL_C_Stat1_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_DAC4_ECM_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_DAC4_EM2_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_DAC4_ISM_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_DAC4_TCM_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_Dimming_Stat_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_Door_RL_Stat_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_Door_RR_Stat_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_EAC_Stat_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_EL_Stat_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_EVC_CfgBit_33_64_AR2 = change_status_p;
    //@CH_Nodes::CH__STPDU_EIS_HLI_Lt_Ext_Lgt_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_HU_State_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_HVAC_Disp_Stat1_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_HVAC_OBD_DTC_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_HVAC_Rs2_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_HVAC_Rs_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_HVAC_State1_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_ICH_Stat_AR = change_status_p;
   // @CH_Nodes::CH__STPDU_EIS_IC_BasicInfo2_AR2 = change_status_p;
   // @CH_Nodes::CH__STPDU_EIS_IC_Date_Time_AR2 = change_status_p;
    ///@CH_Nodes::CH__STPDU_EIS_IC_EnergyMngmnt_Stat_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_IC_Settings_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_IHC_Lgt_Stat_HLI_2_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_IHC_Lgt_Stat_HLI_AR2 = change_status_p;
    //@CH_Nodes::CH__STPDU_EIS_IL_Stat_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_LDC_Disp_Stat_IC_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_Mirr_Adj_Lt_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_Mirr_Adj_Rt_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_NAVI_Pos1_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_NAVI_Pos2_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_NAVI_Pos3_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_NAVI_Pos4_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_NAVI_Pos5_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_NVP_Stat1_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_ORC_Impact_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_PN14_Rs1_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_PN14_Rs2_AR = change_status_p;
   // @CH_Nodes::CH__STPDU_EIS_PT_Rq_RDU_Gw_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_PreCond_On_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_PreCond_Stat_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_SPCR_Stat_BC_F_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_SPL_Obj1_Obj2_NV_AR2 = change_status_p;
    ///@CH_Nodes::CH__STPDU_EIS_SPV_Actn_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_SPV_Alm_Rq_AR = change_status_p;
   /// @CH_Nodes::CH__STPDU_EIS_SPV_Stat_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_SeatAdj_FL_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_SeatAdj_FR_Rq_AR = change_status_p;
    //@CH_Nodes::CH__STPDU_EIS_TBCC_Req_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_TSA_Disp_Rq1_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_TSA_Disp_Rq2_AR = change_status_p;
   /// @CH_Nodes::CH__STPDU_EIS_Tire_State_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_TrafficInfo_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_VIN_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EIS_WUDOP_EIS_FR = change_status_p;
    //CPC
    @CH_Nodes::CH__STPDU_CPC_HumanMachineIfc_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_Adblue_Disp_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_Adblue_Disp_Warn_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_Assyst_Stat2_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_Assyst_Stat_AR = change_status_p;
   /// @CH_Nodes::CH__STPDU_CPC_DCDC1_Rs_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_ECM_DAC4_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_ECO_Score_Disp_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_EM01_Stat1_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_EM01_Stat2_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_EM01_Trq_Rs_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_EM_DAC4_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_ESP_OBD_Data_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_EnergyMngmnt_PreCond_Stat_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_EngCtrl_Disp_Rq_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_EngCtrl_OBD1_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_EngCtrl_Stat_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_Eng_Rs_1_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_Eng_Rs_2_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_Eng_Rs_3_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_Eng_Rs_EM_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_Fuel_Stat2_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_FuelLvl_Stat_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_HumanMachineIfc_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_ISM_DAC4_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_OBL_DC_Output_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_PN14_Gen_Rs_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_PNHV_EnergyMngmntSet_Rs1_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_PNHV_EnergyMngmntSet_Rs2_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_PNHV_EnergyMngmnt_Stat2_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_PNHV_EnergyMngmnt_Stat3_AR2 = change_status_p;
  ///  @CH_Nodes::CH__STPDU_CPC_PNHV_Rq_AR = change_status_p;
  ///  @CH_Nodes::CH__STPDU_CPC_PNHV_Stat_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_PT_ThermM_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_PtHyb_Mngmnt_Rq1_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_PtMngmnt_Disp_Rq_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_SBW_DrvPosn_Disp_Rq_ISM_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_SBW_DrvPosn_Disp_Rq_TCM_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_SBW_Stat_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_TCM_DAC4_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_TCM_Data3_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_TCM_State3_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_TC_EBBC_Disp_Rq_ECM_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_ThermMngmnt_1_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_ThermMngmnt_4_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_VehPwrMngmnt_EMM_Stat2_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_VehPwrMngmnt_Rq_AR = change_status_p;
    @CH_Nodes::CH__STPDU_CPC_WIA_EngTrq_AR = change_status_p;
    //EPS
    //@CH_Nodes::CH__STPDU_EPS_ASM_Resp_AR = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_DTQ_Rs_AR2 = change_status_p;
    /*todo @CH_Nodes::CH__STPDU_EPS_ECU_APPL_EPS1 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_ECU_APPL_EPS2 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_Meas_EPS_1 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_Meas_EPS_2 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_Meas_EPS_3 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_Meas_EPS_4 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_Meas_EPS_5 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_Meas_EPS_6 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_Meas_EPS_7 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_Meas_EPS_8 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_Meas_EPS_9 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_Meas_EPS_A = change_status_p;*/
    @CH_Nodes::CH__STPDU_EPS_ROE_EPS = change_status_p;
    //@CH_Nodes::CH__STPDU_EPS_STA_Rs1_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_EPS_WUDOP_EPS_FR = change_status_p;
    //ESP
    @CH_Nodes::CH__STPDU_ESP_ESP_Disp_Rq2_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_ESP_ESP_OBD_Stat_AR = change_status_p;
    @CH_Nodes::CH__STPDU_ESP_Eng_Susp_Rq_AS_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_ESP_LDC_Disp_Rq_ESP_AR = change_status_p;
    @CH_Nodes::CH__STPDU_ESP_PT_Rq_ESP_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_ESP_PresfCtrl_Rq_ESP_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_ESP_ROE_ESP = change_status_p;
    @CH_Nodes::CH__STPDU_ESP_St_Rq_STA_AR2 = change_status_p;
    //@CH_Nodes::CH__STPDU_ESP_TBCC_Resp_AR = change_status_p;
    @CH_Nodes::CH__STPDU_ESP_VehDyn_Stat1_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_ESP_WUDOP_ESP_FR = change_status_p;
    //LRR
    @CH_Nodes::CH__STPDU_LRR_DTR_Obj_A_FR2 = change_status_p;
    //@CH_Nodes::CH__STPDU_LRR_DTR_Obj_A_Part2_FR = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_DTR_Obj_B_FR2 = change_status_p;
    //@CH_Nodes::CH__STPDU_LRR_DTR_Obj_B_Part2_FR = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_DTR_Obj_C_FR2 = change_status_p;
    //@CH_Nodes::CH__STPDU_LRR_DTR_Obj_C_Part2_FR = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_DTR_Obj_D_FR2 = change_status_p;
    //@CH_Nodes::CH__STPDU_LRR_DTR_Obj_D_Part2_FR = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_DTR_Polyg_Lt_FR2 = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_DTR_Polyg_Rt_FR2 = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_DTR_Stat_FR2 = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_ROE_LRR = change_status_p;
    /*todo @CH_Nodes::CH__STPDU_LRR_XCP_Rs_RES_ERR_FR = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_XCP_Rs_VARIABLE1_FR = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_XCP_Rs_VARIABLE2_FR = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_XCP_Rs_VARIABLE3_FR = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_XCP_Rs_VARIABLE4_FR = change_status_p;
    @CH_Nodes::CH__STPDU_LRR_XCP_Rs_VARIABLE5_FR = change_status_p;*/
    //MPC
    /*@CH_Nodes::CH__STPDU_MPC_ALDW_Disp_Warn_Rq_Gw_AR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_ALDW_LaneAttr1_Gw_AR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_ALDW_LaneAttr2_Gw_AR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_ALDW_LaneAttr3_Gw_AR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_ALDW_LaneAttr4_AR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_ALDW_Polyg_FR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_ALDW_VLN_AR = change_status_p;*/
    //@CH_Nodes::CH__STPDU_MPC_CamObj_1_DTQ_FR = change_status_p;
    //@CH_Nodes::CH__STPDU_MPC_CamObj_2_DTQ_FR = change_status_p;
    //@CH_Nodes::CH__STPDU_MPC_CamObj_3_DTQ_FR = change_status_p;
    //@CH_Nodes::CH__STPDU_MPC_CamObj_AB_BPQ_FR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_CamObj_A_Posn_FR2 = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_CamObj_B_Posn_FR2 = change_status_p;
    //@CH_Nodes::CH__STPDU_MPC_Cam_Polyg_FR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_Cam_Stat_AR2 = change_status_p;
    //@CH_Nodes::CH__STPDU_MPC_DTQ_DrawbarAngl_AR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_IHC_Lgt_Stat_MPC_Gw_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_IHC_Plus_HL_Stat_AR2 = change_status_p;
    //@CH_Nodes::CH__STPDU_MPC_Meas_MPC_1 = change_status_p;
    //@CH_Nodes::CH__STPDU_MPC_Meas_MPC_2 = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_Preview_Header1_FR2 = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_Preview_Header2_FR2 = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_Preview_ProfData1_FR2 = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_Preview_ProfData2_FR2 = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_ROE_SMPC = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_SPL_Obj1_Obj2_MPC_AR2 = change_status_p;
  ///  @CH_Nodes::CH__STPDU_MPC_TSA_Disp_Rq1_Gw_AR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_TSA_Disp_Rq2_Gw_AR = change_status_p;
    /*todo @CH_Nodes::CH__STPDU_MPC_XCP_Rs_RES_ERR_FR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_XCP_Rs_VARIABLE1_FR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_XCP_Rs_VARIABLE2_FR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_XCP_Rs_VARIABLE3_FR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_XCP_Rs_VARIABLE4_FR = change_status_p;
    @CH_Nodes::CH__STPDU_MPC_XCP_Rs_VARIABLE5_FR = change_status_p;*/
    //RDU
    //@CH_Nodes::CH__STPDU_RDU_BSM_Disp_Warn_Rq_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_BrkSys_Rq_YMAS_AR2 = change_status_p;
   /// @CH_Nodes::CH__STPDU_RDU_Brk_SPCR_Rq_RDU_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_CMS_PI_State_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_DTQ_Disp_Warn_Rq_AR2 = change_status_p;
    //@CH_Nodes::CH__STPDU_RDU_DTQ_Obj_Pres_AR = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_DTQ_Rq1_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_DTQ_Rq2_AR2 = change_status_p;
   /// @CH_Nodes::CH__STPDU_RDU_LDC_Disp_Rq_RDU_AR = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_LDP_Warn_Rq_AR2 = change_status_p;
  ///  @CH_Nodes::CH__STPDU_RDU_PT_Rq_RDU_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_RDU_GlobalAttr_AR2 = change_status_p;
   /// @CH_Nodes::CH__STPDU_RDU_RDU_Gnrl_Stat_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_ROE_RDU = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_SCS_Stat1_RDU_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_SCS_Stat2_RDU_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_Veh_Stat_RDU_FR2 = change_status_p;
    /*todo @CH_Nodes::CH__STPDU_RDU_XCP_Rs_RES_ERR_FR = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_XCP_Rs_VARIABLE1_FR = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_XCP_Rs_VARIABLE2_FR = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_XCP_Rs_VARIABLE3_FR = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_XCP_Rs_VARIABLE4_FR = change_status_p;
    @CH_Nodes::CH__STPDU_RDU_XCP_Rs_VARIABLE5_FR = change_status_p;*/
    //SCCM
    /*todo @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM1 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM2 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM3 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM4 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM5 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM6 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM7 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM8 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCM9 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_ECU_APPL_SCCMA = change_status_p;*/
    @CH_Nodes::CH__STPDU_SCCM_LDC_SBW_Rq_SCCM_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_ROE_SCCM = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_SCCM_Sw_Stat_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_StWhl_Sw_Stat_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_SCCM_WUDOP_SCCM_FR = change_status_p;
    //SPC
    //@CH_Nodes::CH__STPDU_SPC_Meas_SPC_1 = change_status_p;
    //@CH_Nodes::CH__STPDU_SPC_Meas_SPC_2 = change_status_p;
    @CH_Nodes::CH__STPDU_SPC_Preview_Data_SPC_AR = change_status_p;
    @CH_Nodes::CH__STPDU_SPC_ROE_SPC = change_status_p;
    @CH_Nodes::CH__STPDU_SPC_SPC_SwLED_Msg_Rq_AR2 = change_status_p;
    @CH_Nodes::CH__STPDU_SPC_VehLvl_Stat_AR2 = change_status_p;
    /*todo @CH_Nodes::CH__STPDU_SPC_XCP_Rs_RES_ERR_FR = change_status_p;
    @CH_Nodes::CH__STPDU_SPC_XCP_Rs_VARIABLE1_FR = change_status_p;
    @CH_Nodes::CH__STPDU_SPC_XCP_Rs_VARIABLE2_FR = change_status_p;
    @CH_Nodes::CH__STPDU_SPC_XCP_Rs_VARIABLE3_FR = change_status_p;
    @CH_Nodes::CH__STPDU_SPC_XCP_Rs_VARIABLE4_FR = change_status_p;
    @CH_Nodes::CH__STPDU_SPC_XCP_Rs_VARIABLE5_FR = change_status_p;*/
}

on timer second_start_timer
{


    cancelTimer(second_start_timer);
    if(getValue(VSys_VDT_Active) == RESET)
    {
        if(0 != DiagSetTarget("ParkMan213") )
        {
            write("Diagnostic Initialization was not successful! ");
        }
        else
        {   
            write("Was successful initial");
            DiagStopTesterPresent();
        }
    }
    
    if(getValue(VSys_Optimize_PDU_LED) == SET)
    {
        //Deactivation of Optimization
        VSys_Optimize(DEACTIVATION);
    }
    else
    {
        //Activation of Optimization
        VSys_Optimize(ACTIVATION);
    }

    /* Set Diagnose_Panel Ready */
    VDS_Already_Init = SET;
}

/*--------------------------------------------------------------------------------------------------
Timer to check the sleep-modus-status
Erstellt: 07.12.2011        Geändert: 07.12.2011
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer sleep_modus_check_timer
{
    cancelTimer(sleep_modus_check_timer);
    if(@CH_NM::CH__NMStat_PARK == RESET)
        putValue(VSys_Sleep_Modus_Status,RESET);
    else
        putValue(VSys_Sleep_Modus_Status,SET);
    setTimer(sleep_modus_check_timer, SLEEP_MODUS_CHECK_TIMING);
}

/*--------------------------------------------------------------------------------------------------
Sleep Modus aktivieren
Erstellt: 07.12.2011        Geändert: 30.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_Sleep_Modus_Button
{
  
        setSignal(Gr_Target, 13);  // P
        setSignal(Gr, 13);  // P
        setSignal(TSL_Posn_Target, GEAR_P); // P
        setSignal(PT_Rdy_V2,0x00);
        VSleep_Modus_Request = SET;
        SetSignal(ISw_Stat, IGN_STAT_KL0);
        VSys_Optimize (0x01);
        @sysvar::CH_NM::CH_DISPLAY_NM_WAKEUPNM = 0; 

}

/*--------------------------------------------------------------------------------------------------
Change selected messages
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Msg_Scroll
{
    if(VDS_Already_Init == SET)
    { 
        dummy_l = (getValue(VDS_Msg_Scroll) - (VDS_SUPPORTED_MSG-2)) * (-1);
        VDS_Change_View_Msg(dummy_l);

        setTimer(VDS_Update_Timer, VDS_UPDATE_TIMING);
    }
}

/*--------------------------------------------------------------------------------------------------
Change selected messages
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VDS_Change_View_Msg (byte new_nbr_p)
{
    /* VDS_Msg_Nbr */
    putValue(VDS_Msg_Nbr_0, new_nbr_p);
    putValue(VDS_Msg_Nbr_1, new_nbr_p+1);
}

/*--------------------------------------------------------------------------------------------------
Change selected datas
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data_Scroll
{
    VDS_Change_View_Datas(getValue(VDS_Data_Scroll));

    setTimer(VDS_Update_Timer, VDS_UPDATE_TIMING);
}

/*--------------------------------------------------------------------------------------------------
Change selected datas
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VDS_Change_View_Datas (byte new_nbr_p)
{
    /* VDS_DataX_Act */
    putValue(VDS_Data0_Act, new_nbr_p);
    putValue(VDS_Data1_Act, new_nbr_p+1);
    putValue(VDS_Data2_Act, new_nbr_p+2);
    putValue(VDS_Data3_Act, new_nbr_p+3);
    putValue(VDS_Data4_Act, new_nbr_p+4);
    putValue(VDS_Data5_Act, new_nbr_p+5);
    putValue(VDS_Data6_Act, new_nbr_p+6);
    putValue(VDS_Data7_Act, new_nbr_p+7);    
}

/*--------------------------------------------------------------------------------------------------
Change Message_Typ
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Msg_Type_0
{
    if(VDS_Already_Init == SET)
    {
        switch(getValue(VDS_Msg_Type_0))
        {
            case VDS_DIAG_RQ_GLOBAL_1_FR:
                    putValue(VDS_Msg_ID_0, VDS_DIAG_RQ_GLOBAL_1_FR_SLOT);
                break;

            case VDS_DIAG_RS_PARK_FR:
                    putValue(VDS_Msg_ID_0, VDS_DIAG_RS_PARK_FR_SLOT);
                break;
        }

        VDS_Change_Msg(0x00,  getValue(VDS_Msg_Type_0)); 
    }
}

/*--------------------------------------------------------------------------------------------------
Change Message_Typ
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Msg_Type_1
{
    if(VDS_Already_Init == SET)
    {
        switch(getValue(VDS_Msg_Type_1))
        {
            case VDS_DIAG_RQ_GLOBAL_1_FR:
                    putValue(VDS_Msg_ID_1, VDS_DIAG_RQ_GLOBAL_1_FR_SLOT);
                break;

            case VDS_DIAG_RS_PARK_FR:
                    putValue(VDS_Msg_ID_1, VDS_DIAG_RS_PARK_FR_SLOT);
                break;
        }

        VDS_Change_Msg(0x01,  getValue(VDS_Msg_Type_1));
    } 
}

/*--------------------------------------------------------------------------------------------------
Change Data0_0
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data0_0
{
    if(VDS_Already_Init == SET)
    {   
        /* Update at the Array */
        VDS_Change_Data(0x00, 0x00, getValue(VDS_Data0_0));
    }
}

/*--------------------------------------------------------------------------------------------------
Change data at the array
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VDS_Change_Data(byte direct_msg_p, byte direct_data_p,  byte value_p) 
{
    VDS_Datas[direct_msg_p + getValue(VDS_Msg_Nbr_0)][direct_data_p + getValue(VDS_Data0_Act)] = value_p;
}

/*--------------------------------------------------------------------------------------------------
Change Data0_1
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data0_1
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x00, 0x01, getValue(VDS_Data0_1));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data0_2
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data0_2
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x00, 0x02, getValue(VDS_Data0_2));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data0_3
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data0_3
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x00, 0x03, getValue(VDS_Data0_3));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data0_4
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data0_4
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x00, 0x04, getValue(VDS_Data0_4));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data0_5
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data0_5
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x00, 0x05, getValue(VDS_Data0_5));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data0_6
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data0_6
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x00, 0x06, getValue(VDS_Data0_6));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data0_7
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data0_7
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x00, 0x07, getValue(VDS_Data0_7));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data1_0
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data1_0
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x01, 0x00, getValue(VDS_Data1_0));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data1_1
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data1_1
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x01, 0x01, getValue(VDS_Data1_1));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data1_2
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data1_2
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x01, 0x02, getValue(VDS_Data1_2));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data1_3
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data1_3
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x01, 0x03, getValue(VDS_Data1_3));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data1_4
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data1_4
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x01, 0x04, getValue(VDS_Data1_4));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data1_5
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data1_5
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x01, 0x05, getValue(VDS_Data1_5));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data1_6
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data1_6
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x01, 0x06, getValue(VDS_Data1_6));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Data1_7
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data1_7
{
    if(VDS_Already_Init == SET)
    {
        /* Update at the Array */
        VDS_Change_Data(0x01, 0x07, getValue(VDS_Data1_7));
    }
}

/*--------------------------------------------------------------------------------------------------
Change Msg at the array
Erstellt: 05.01.2012        Geändert: 23.03.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VDS_Change_Msg(byte direct_msg_p,  byte value_p) 
{
    VDS_Msgs[direct_msg_p + getValue(VDS_Msg_Nbr_0)] = value_p;

    /* Set DefaultValues */
    switch(value_p)
    {
        case VDS_DIAG_RQ_GLOBAL_1_FR:
            VDS_Datas[direct_msg_p + getValue(VDS_Msg_Nbr_0)][0x00] = 0x74;
            VDS_Datas[direct_msg_p + getValue(VDS_Msg_Nbr_0)][0x01] = 0x30;
            VDS_Datas[direct_msg_p + getValue(VDS_Msg_Nbr_0)][0x02] = 0xEF;
            VDS_Datas[direct_msg_p + getValue(VDS_Msg_Nbr_0)][0x03] = 0x00;
            VDS_Datas[direct_msg_p + getValue(VDS_Msg_Nbr_0)][0x04] = 0x40;
            break;

        case VDS_DIAG_RS_PARK_FR:
            VDS_Datas[direct_msg_p + getValue(VDS_Msg_Nbr_0)][0x00] = 0xEF;
            VDS_Datas[direct_msg_p + getValue(VDS_Msg_Nbr_0)][0x01] = 0x00;
            VDS_Datas[direct_msg_p + getValue(VDS_Msg_Nbr_0)][0x02] = 0x72;
            VDS_Datas[direct_msg_p + getValue(VDS_Msg_Nbr_0)][0x03] = 0x30;
            VDS_Datas[direct_msg_p + getValue(VDS_Msg_Nbr_0)][0x04] = 0x40;
            break;
    }
    putValue(VDS_Data_Scroll, 0x00);
    
    VDS_Update_Status = RESET;
    setTimer(VDS_Update_Timer, 20);
}

/*--------------------------------------------------------------------------------------------------
Timer to Update the Array_Values
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer VDS_Update_Timer
{
    cancelTimer(VDS_Update_Timer);
    switch(VDS_Update_Status)
    {
        case 0x00:
            VDS_Already_Init = RESET;
            /* Update Msg */
            putValue(VDS_Msg_Type_0, VDS_Msgs[getValue(VDS_Msg_Nbr_0)]);
            putValue(VDS_Msg_Type_1, VDS_Msgs[getValue(VDS_Msg_Nbr_1)]);
            /* Update Dates */
            putValue(VDS_Data0_0, VDS_Datas[getValue(VDS_Msg_Nbr_0)][getValue(VDS_Data0_Act)+0x00]);
            putValue(VDS_Data0_1, VDS_Datas[getValue(VDS_Msg_Nbr_0)][getValue(VDS_Data0_Act)+0x01]);
            putValue(VDS_Data0_2, VDS_Datas[getValue(VDS_Msg_Nbr_0)][getValue(VDS_Data0_Act)+0x02]);
            putValue(VDS_Data0_3, VDS_Datas[getValue(VDS_Msg_Nbr_0)][getValue(VDS_Data0_Act)+0x03]);
            putValue(VDS_Data0_4, VDS_Datas[getValue(VDS_Msg_Nbr_0)][getValue(VDS_Data0_Act)+0x04]);
            putValue(VDS_Data0_5, VDS_Datas[getValue(VDS_Msg_Nbr_0)][getValue(VDS_Data0_Act)+0x05]);
            putValue(VDS_Data0_6, VDS_Datas[getValue(VDS_Msg_Nbr_0)][getValue(VDS_Data0_Act)+0x06]);
            putValue(VDS_Data0_7, VDS_Datas[getValue(VDS_Msg_Nbr_0)][getValue(VDS_Data0_Act)+0x07]);
            putValue(VDS_Data1_0, VDS_Datas[getValue(VDS_Msg_Nbr_1)][getValue(VDS_Data0_Act)+0x00]);
            putValue(VDS_Data1_1, VDS_Datas[getValue(VDS_Msg_Nbr_1)][getValue(VDS_Data0_Act)+0x01]);
            putValue(VDS_Data1_2, VDS_Datas[getValue(VDS_Msg_Nbr_1)][getValue(VDS_Data0_Act)+0x02]);
            putValue(VDS_Data1_3, VDS_Datas[getValue(VDS_Msg_Nbr_1)][getValue(VDS_Data0_Act)+0x03]);
            putValue(VDS_Data1_4, VDS_Datas[getValue(VDS_Msg_Nbr_1)][getValue(VDS_Data0_Act)+0x04]);
            putValue(VDS_Data1_5, VDS_Datas[getValue(VDS_Msg_Nbr_1)][getValue(VDS_Data0_Act)+0x05]);
            putValue(VDS_Data1_6, VDS_Datas[getValue(VDS_Msg_Nbr_1)][getValue(VDS_Data0_Act)+0x06]);
            putValue(VDS_Data1_7, VDS_Datas[getValue(VDS_Msg_Nbr_1)][getValue(VDS_Data0_Act)+0x07]);
            /* Update Activation */
            putValue(VDS_Msg_Act_0, VDS_Activation[getValue(VDS_Msg_Nbr_0)]);
            putValue(VDS_Msg_Act_1, VDS_Activation[getValue(VDS_Msg_Nbr_1)]);
            /* Update Timing */
            putValue(VDS_Data_Timing, VDS_Data_Timing_Value[getValue(VDS_Msg_Nbr_0)]);

            VDS_Update_Status = 0x01;
            setTimer(VDS_Update_Timer, 20);
            break;
        case 0x01:
            VDS_Already_Init = SET;
            VDS_Update_Status = 0x00;
            break;
    }    
}

/*--------------------------------------------------------------------------------------------------
Change VDS_Msg_Act_0
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Msg_Act_0
{
    if(VDS_Already_Init == SET)
    {
        VDS_Set_Activation(getValue(VDS_Msg_Nbr_0), getValue(VDS_Msg_Act_0)); 
    }
}

/*--------------------------------------------------------------------------------------------------
Set Activation
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VDS_Set_Activation(byte direct_msg_p, byte value_p) 
{
    if(value_p == SET)
    {
        for(dummy_l = RESET; dummy_l <= direct_msg_p; dummy_l++)
        {
            VDS_Activation[dummy_l] = SET;
        }
    }
    else
    {
        for(dummy_l = direct_msg_p; dummy_l < VDS_SUPPORTED_MSG; dummy_l++)
        {
            VDS_Activation[dummy_l] = RESET;
        }
    }

    setTimer(VDS_Update_Timer,VDS_UPDATE_TIMING);
}

/*--------------------------------------------------------------------------------------------------
Change VDS_Msg_Act_1
Erstellt: 05.01.2012        Geändert: 05.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Msg_Act_1
{
    if(VDS_Already_Init == SET)
    {
        VDS_Set_Activation(getValue(VDS_Msg_Nbr_1), getValue(VDS_Msg_Act_1)); 
    }
}

/*--------------------------------------------------------------------------------------------------
Aktivieren bzw. Deaktivieren vom Kombi-Sim
Erstellt: 12.01.2012        Geändert: 13.06.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VKombi_Activation
{
    if(getValue(VSys_Real_Kombi) != SET)
    {
        if(getValue(VKombi_Activation) == SET)
        {
            if(getValue(VKombi_Status) == SET)
                putValue(VKombi_Status, RESET);
            else
                putValue(VKombi_Status, SET);
        }
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Release PTS_Button
Erstellt: 13.01.2012        Geändert: 13.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer Auto_PTS_Pressed_Timer
{
    cancelTimer(Auto_PTS_Pressed_Timer);
    setSignal(ParkSw_Psd, PTS_BUTTON_RELEASED);    
}

/*--------------------------------------------------------------------------------------------------
Timer for Auto_PTS_Button
Erstellt: 13.01.2012        Geändert: 13.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer Auto_PTS_Timer
{
    cancelTimer(Auto_PTS_Timer);
    
    auto_pts_timer_status = RESET;

    /* Start PTS-Button */
    if(getValue(VSys_Auto_PTS_Status) == SET)
    {
        cancelTimer(Auto_PTS_Pressed_Timer);
        setSignal(ParkSw_Psd, PTS_BUTTON_PRESSED);
        setTimer(Auto_PTS_Pressed_Timer, auto_pts_pressed_timing); 
    }
}

/*--------------------------------------------------------------------------------------------------
PDU ParkWarn_AR
Erstellt: 13.01.2012        Geändert: 13.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on frPDU ParkWarn_AR2
{
    /* Systemcheck for Auto_PTS */
    if(getValue(VSys_Auto_PTS_Status) == SET)
    {
        if(this.ParkSwLED_Rq == OFF)
        {
            cancelTimer(Auto_PTS_Timer);
            auto_pts_timer_status = RESET;
        }
        else
        {
            if(auto_pts_timer_status == RESET)
            {
                auto_pts_timer_status = SET;
                setTimer(Auto_PTS_Timer, getValue(VSys_Auto_PTS_Time));
            }
        }
    }
}

/*--------------------------------------------------------------------------------------------------
Set Auto-PTS-Button
Erstellt: 13.01.2012        Geändert: 13.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_Auto_PTS_Button
{
    if(getValue(VSys_Auto_PTS_Button) == SET)
    {
        if(getValue(VSys_Auto_PTS_Status) == SET)
            putValue(VSys_Auto_PTS_Status, RESET);
        else
            putValue(VSys_Auto_PTS_Status, SET);
    }
}

/*--------------------------------------------------------------------------------------------------
Set Low Volume WEs
Erstellt: 13.01.2012        Geändert: 13.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_Volume_Low
{
    if(getValue(VSys_Volume_Low) == SET)
    {
        putValue(VSys_Volume_Front, VOLUME_50);
        putValue(VSys_Volume_Rear, VOLUME_50);
    }
}

/*--------------------------------------------------------------------------------------------------
Set Default Volume WEs
Erstellt: 13.01.2012        Geändert: 13.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_Volume_Def
{
    if(getValue(VSys_Volume_Def) == SET)
    {
        putValue(VSys_Volume_Front, VOLUME_80);
        putValue(VSys_Volume_Rear, VOLUME_80);
    }
}

/*--------------------------------------------------------------------------------------------------
Start Change Volume
Erstellt: 13.01.2012        Geändert: 13.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_Volume_Change
{
    if(getValue(VSys_Volume_Change) == SET)
    {
        /* Check if still working */
        if(volume_change_status == RESET)
        {
            volume_change_status = VOLUME_CHANGE_STATUS_READ_RQ;
            cancelTimer(volume_change_timer);
            setTimer(volume_change_timer,VOLUME_CHANGE_TIMEOUT);
            VSys_Volume_Change_Manager();
        }
    }
}

/*--------------------------------------------------------------------------------------------------
Volume Change Manager
Erstellt: 13.01.2012        Geändert: 13.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_Volume_Change_Manager()
{
    switch(volume_change_status)
    {
        case VOLUME_CHANGE_STATUS_READ_RQ:
            putValue(VSys_Volume_Status, 25);
            VSys_Prepare_to_Send_DIAG_RQ();
            DIAG_RQ.BYTE(0x05) = 0x03;
            DIAG_RQ.BYTE(0x07) = 0x03;
            DIAG_RQ.BYTE(0x08) = 0x22;
            DIAG_RQ.BYTE(0x09) = 0x04;
            DIAG_RQ.BYTE(0x0A) = 0x12;
            FrUpdatePDU(DIAG_RQ, 0x01, 0x01);
            break;

        case VOLUME_CHANGE_STATUS_WRITE_RQ:
            putValue(VSys_Volume_Status, 50);
            VSys_Prepare_to_Send_DIAG_RQ();
            DIAG_RQ.BYTE(0x05) = 0x05;
            DIAG_RQ.BYTE(0x07) = 0x05;
            DIAG_RQ.BYTE(0x08) = 0x2E;
            DIAG_RQ.BYTE(0x09) = 0x04;
            DIAG_RQ.BYTE(0x0A) = 0x12;
            DIAG_RQ.BYTE(0x0B) = (volume_change_datas[0x00] & 0xF8) | getValue(VSys_Volume_Front);
            DIAG_RQ.BYTE(0x0C) = (volume_change_datas[0x01] & 0xF8) | getValue(VSys_Volume_Rear);
            FrUpdatePDU(DIAG_RQ, 0x01, 0x01);
            break;

        case VOLUME_CHANGE_STATUS_WRITE_RS:
            putValue(VSys_Volume_Status, 100);
            volume_change_status = RESET;
            break;
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Timeout "Volume Change"
Erstellt: 13.01.2012        Geändert: 13.01.2012
Erstellt: Markus Kunius     Geändert: Markus Kunius
---------------------------------------------------------------------------------------------------*/

on timer volume_change_timer
{
    cancelTimer(volume_change_timer);
    volume_change_status = RESET; 
}

/*--------------------------------------------------------------------------------------------------
Prepare to Send DIAG_RQ
Erstellt: 13.01.2012        Geändert: 13.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_Prepare_to_Send_DIAG_RQ()
{
    for(dummy_l = RESET; dummy_l < 42; dummy_l++)
    {
        DIAG_RQ.BYTE(dummy_l) = RESET;
    }
    DIAG_RQ.BYTE(0x00) = 0x74;
    DIAG_RQ.BYTE(0x01) = 0x30;
    DIAG_RQ.BYTE(0x02) = 0xEF;
    DIAG_RQ.BYTE(0x04) = 0x40;
}

/*--------------------------------------------------------------------------------------------------
PDU IC_BasicInfo_AR
Erstellt: 25.01.2012        Geändert: 25.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on signal VehSpd_X
{
  
  setsignal(VehSpd_X_Max,getsignal(VehSpd_X));
    /* WHL_STATUS_SIMULATION */
    if(getValue(VSys_WHL_Status) == SET)
    {
        whl_sim_speed = getsignal(VehSpd_X);
    }
}

/*--------------------------------------------------------------------------------------------------
Statusänderung WHL_STATUS
Erstellt: 25.01.2012        Geändert: 13.06.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_WHL_Change
{
    if(getValue(VSys_WHL_Change) == SET)
    {
        cancelTimer(WHL_Timer);
        if(getValue(VSys_WHL_Status) == SET)
        {
            putValue(VSys_WHL_Status, RESET);
            /* Set Default-Values */
            setSignal(WhlDir_FL_Stat, RESET);
            setSignal(WhlDir_FR_Stat, RESET);
            setSignal(WhlDir_RL_Stat, RESET);
            setSignal(WhlDir_RR_Stat, RESET);
        }
        else
        {
            /* Init */
            setSignal(StWhl_Angl, 0);
            setSignal(EPS_FtWhlAngl, 0);
            setSignal(StW_Trq_EPS, 0);
            setSignal(EPS_FtwhlAngl_ASM, 0);
            //setSignal(EPS_StRackPosn, 0);
            setSignal(VehAccel_X_V2, 0x02);
            setSignal(VehAccel_X_Offset, 0x00);
            setSignal(VehAccel_X_Qual, 0x02);
            setSignal(VehAccel_Y_V2, 0x02);
            setSignal(VehAccel_Y_Offset, 0x00);
            setSignal(VehAccel_Y_Qual, 0x02);
            setSignal(VehYawRate_Raw, 0x02);
            setSignal(VehYawRateOffset_V2, 0x00);
            setSignal(VehYawRate_Raw_Qual, 0x02);
            setSignal(PARK_Brk_Stat_ESP,4);
    
            putValue(VSys_WHL_Status, SET);
            setTimer(WHL_Timer, CYCLE_WHL_TIMING);
        }
    }    
}

/*--------------------------------------------------------------------------------------------------
WHL_Status_Simulation_Manager
Erstellt: 25.01.2012        Geändert: 13.06.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_WHL_Status_Manager ()
{
    if((getValue(VSys_WHL_Status) == SET) && (getValue(VSys_VS6_Status) != SET))
    {
        /* Steering_WHL */
        //todo SetSignal(EPS_StRackPosn,getSignal(StWhl_Angl)/6);
        /* WHL_SIM_IMPULS */
        dummy_f = ((float) whl_sim_speed)/WHL_BASIS_SPEED;
        whl_impluse_fl += dummy_f;
        whl_impluse_fr += dummy_f;
        whl_impluse_rl += dummy_f;
        whl_impluse_rr += dummy_f;
        if(whl_impluse_fl > 254)
        {
            whl_impluse_fl -= 254;
        }
        if(whl_impluse_fr > 254)
        {
            whl_impluse_fr -= 254;
        }
        if(whl_impluse_rl > 254)
        {
            whl_impluse_rl -= 254;
        }
        if(whl_impluse_rr > 254)
        {
            whl_impluse_rr -= 254;
        }
        $Whl_Lt_Stat_AR2::WhlPlsCnt_FL = whl_impluse_fl;
        $Whl_Rt_Stat_AR2::WhlPlsCnt_FR = whl_impluse_fr;
        $Whl_Lt_Stat_AR2::WhlPlsCnt_RL = whl_impluse_rl;
        $Whl_Rt_Stat_AR2::WhlPlsCnt_RR = whl_impluse_rr;

        /* WHL_SIM_DIRECTION & WHL_SIM_PRM */
        if(whl_sim_speed > RESET)
        {
            dummy_f = ((((float) whl_sim_speed)/10) * WHL_BASIS_SPEED_RPM)/2;
            setSignal(WhlRPM_FL, ((word) dummy_f));
            setSignal(WhlRPM_FR, ((word) dummy_f));
            setSignal(WhlRPM_RL, ((word) dummy_f));
            setSignal(WhlRPM_RR, ((word) dummy_f));
            switch(whl_sim_gearbox)
            {
                case GEAR_R:
                    setSignal(WhlDir_FL_Stat, 0x02);
                    setSignal(WhlDir_FR_Stat, 0x02);
                    setSignal(WhlDir_RL_Stat, 0x02);
                    setSignal(WhlDir_RR_Stat, 0x02);
                    setSignal(RevGr_Engg, 0x01);
                    break;

                case GEAR_D:
                    setSignal(WhlDir_FL_Stat, 0x01);
                    setSignal(WhlDir_FR_Stat, 0x01);
                    setSignal(WhlDir_RL_Stat, 0x01);
                    setSignal(WhlDir_RR_Stat, 0x01);
                    setSignal(RevGr_Engg, 0x00);
                    break;

                default:
                    setSignal(WhlDir_FL_Stat, 0x00);
                    setSignal(WhlDir_FR_Stat, 0x00);
                    setSignal(WhlDir_RL_Stat, 0x00);
                    setSignal(WhlDir_RR_Stat, 0x00);
                    setSignal(RevGr_Engg, 0x00);
                    break;
            }
        }
        else
        {
            setSignal(WhlDir_FL_Stat, 0x00);
            setSignal(WhlDir_FR_Stat, 0x00);
            setSignal(WhlDir_RL_Stat, 0x00);
            setSignal(WhlDir_RR_Stat, 0x00);
            setSignal(WhlRPM_FL, 0x00);
            setSignal(WhlRPM_FR, 0x00);
            setSignal(WhlRPM_RL, 0x00);
            setSignal(WhlRPM_RR, 0x00);
        }
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for the message WHL_Timer
Erstellt: 25.01.2012        Geändert: 25.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer WHL_Timer
{
    cancelTimer(WHL_Timer);
    if(getValue(VSys_WHL_Status) == SET)
    {
        VSys_WHL_Status_Manager();
        setTimer(WHL_Timer, CYCLE_WHL_TIMING);
    }
}

/*--------------------------------------------------------------------------------------------------
Manager for Auto-XCP-Request
Erstellt: 30.01.2012        Geändert: 01.02.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_Auto_XCP_Manager ()
{
    if(getValue(VSys_XCP_Auto_Status) == SET)
    {
        if(
            (RX_Brk_Rq_APX_AR == SET) &&
            (getValue(VSys_Msg_XCP_Rs_VARIABLE2_FR) == RESET)
          )
        {
            putValue(EnvXCPStart_Stop_DAQ, SET);
            cancelTimer(EnvXCPStart_Stop_DAQ_RESET_Timer);
            setTimer(EnvXCPStart_Stop_DAQ_RESET_Timer,100);
        }
    }
}

/*--------------------------------------------------------------------------------------------------
Check if the ecu is still active
Erstellt: 30.01.2012        Geändert: 30.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer RX_Brk_Rq_APX_AR_Timer
{
    cancelTimer(RX_Brk_Rq_APX_AR_Timer);
    RX_Brk_Rq_APX_AR = RESET;
}

/*--------------------------------------------------------------------------------------------------
Read Development IDs
Erstellt: 30.01.2012        Geändert: 30.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_DevID_Read_Rq
{
    if(getValue(VSys_DevID_Read_Rq) == SET)
    {
        VSys_DevID_Read_Request();
    }
}

/*--------------------------------------------------------------------------------------------------
Change Development IDs
Erstellt: 30.01.2012        Geändert: 12.07.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_DevID_Change_Rq
{
    FrPDU DIAG_RQ_GLOBAL_1_FR msg_RQ_l;

    if(getValue(VSys_DevID_Change_Rq) == SET)
    {
        for(loop = RESET; loop < 42; loop++)
        {
            msg_RQ_l.BYTE(loop) = RESET;
        }

        /* Initialisierung */
        msg_RQ_l.BYTE(0x00) = 0x74;
        msg_RQ_l.BYTE(0x01) = 0x30;
        msg_RQ_l.BYTE(0x02) = 0xEF;
        msg_RQ_l.BYTE(0x03) = 0x00;
        msg_RQ_l.BYTE(0x04) = 0x40;
        msg_RQ_l.BYTE(0x05) = 0x04;
        msg_RQ_l.BYTE(0x06) = 0x00;
        msg_RQ_l.BYTE(0x07) = 0x04;
        msg_RQ_l.BYTE(0x08) = 0x2E;
        msg_RQ_l.BYTE(0x09) = 0x0C;
        msg_RQ_l.BYTE(0x0A) = 0x00;
        msg_RQ_l.BYTE(0x0B) = (getValue(VSys_DevID_Write) & 0x0F) | (getValue(VSys_XCP_Mode_Write) & 0xF0);
        //write(" VSys_DevID_Write %x  VSys_XCP_Mode_Write  %x",getValue(VSys_DevID_Write), getValue(VSys_XCP_Mode_Write));
        
        FRUpdatePDU(msg_RQ_l, 1, 1);
        VDiag_DevID_Status = SET;

        //diagrequest _Konfiguration_Development_Identifier_Write diagrequest_devID_change;
        //diagrequest_devID_change.SetPrimitiveByte(0x03, getValue(VSys_DevID_Write));
        //DiagSendRequest(diagrequest_devID_change);
    }
}

/*--------------------------------------------------------------------------------------------------
Tester Present Activation and Deactivation
Erstellt: 30.01.2012        Geändert: 30.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_HardReset
{
     DiagSendRequest( HardReset_service);
}

/*--------------------------------------------------------------------------------------------------
Tester Present Activation and Deactivation
Erstellt: 30.01.2012        Geändert: 30.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_TesterPresent_Change
{
    if(getValue(VSys_TesterPresent_Change) == SET)
    {
        if(getValue(VSys_TesterPresent_Status) == SET)
        {
            putValue(VSys_TesterPresent_Status, RESET);
            DiagStopTesterPresent();
        }
        else
        {
            putValue(VSys_TesterPresent_Status, SET);
            DiagStartTesterPresent();
        }
    }
}

/*--------------------------------------------------------------------------------------------------
Management Function for Identification Read
Erstellt: 31.01.2012        Geändert: 31.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VAnalyse_ID_Manager ()
{
    diagRequest MercedesCarGroupHardware_Read HW_Sachnummer_Read_rq;
    diagRequest HardwareVersion_Read HW_Version_Read_rq;
    diagRequest MercedesCarGroupSoftware_Read SW_Sachnummer_Read_rq;
    diagRequest SoftwareVersion_Read SW_Version_Read_rq;
    diagRequest ActiveDiagnosticInformation_Read Act_Diagnose_Info_rq;
    diagRequest BootSoftwareVersion_Read BOOT_Version_Read_rq;

    switch(VAnalyse_ID_Read_Status)
    {
        case VAnalyse_ID_HW_NBR:
            DiagSendRequest(HW_Sachnummer_Read_rq);
            break;

        case VAnalyse_ID_HW_STAND:
            /* Interpretation of VAnalyse_ID_HW_NBR */
            strncpy(VDiagnose_ID_Result, "A", 21);
            for(loop = RESET; loop < 0x0A; loop++)
            {
                VDiagnose_ID_Result[0x01+loop] = VDiagnose_Bytes[3+loop];
            }
            putValue(VSys_Analyse_HW_Nb, VDiagnose_ID_Result);
            putValue(VSys_Analyse_ID_Bar, getValue(VSys_Analyse_ID_Bar) + 10);
            /* Request VAnalyse_ID_HW_STAND */
            DiagSendRequest(HW_Version_Read_rq);
            break;

        case VAnalyse_ID_SW_NBR:
            /* Interpretation of VAnalyse_ID_HW_STAND */
            strncpy(VDiagnose_ID_Result, "", 21);
            ltoa(VDiagnose_Bytes[3], VDiagnose_ID_Result, 10);
            strncat(VDiagnose_ID_Result, "/", 21);
            ltoa(VDiagnose_Bytes[4], VDiagnose_dummy, 10);
            strncat(VDiagnose_ID_Result, VDiagnose_dummy, 21);
            strncat(VDiagnose_ID_Result,".", 21);
            ltoa(VDiagnose_Bytes[5], VDiagnose_dummy, 10);
            strncat(VDiagnose_ID_Result, VDiagnose_dummy, 21);
            putValue(VSys_Analyse_HW, VDiagnose_ID_Result);
            putValue(VSys_Analyse_ID_Bar, getValue(VSys_Analyse_ID_Bar) + 10);            
            /* Request VAnalyse_ID_HW_STAND */
            DiagSendRequest(SW_Sachnummer_Read_rq);
            break;

        case VAnalyse_ID_SW_STAND:
            /* Interpretation of VAnalyse_ID_HW_NBR */
            strncpy(VDiagnose_ID_Result, "A", 21);
            for(loop = RESET; loop < 0x0A; loop++)
            {
                VDiagnose_ID_Result[0x01+loop] = VDiagnose_Bytes[3+loop];
            }
            putValue(VSys_Analyse_SW_Nb, VDiagnose_ID_Result);
            putValue(VSys_Analyse_ID_Bar, getValue(VSys_Analyse_ID_Bar) + 10);
            /* Request VAnalyse_ID_HW_STAND */
            DiagSendRequest(SW_Version_Read_rq);
            break;

        case VAnalyse_ID_DIAG_ID:
            /* Interpretation of VAnalyse_ID_HW_STAND */
            strncpy(VDiagnose_ID_Result, "", 21);
            ltoa(VDiagnose_Bytes[3], VDiagnose_ID_Result, 10);
            strncat(VDiagnose_ID_Result, "/", 21);
            ltoa(VDiagnose_Bytes[4], VDiagnose_dummy, 10);
            strncat(VDiagnose_ID_Result, VDiagnose_dummy, 21);
            strncat(VDiagnose_ID_Result,".", 21);
            ltoa(VDiagnose_Bytes[5], VDiagnose_dummy, 10);
            strncat(VDiagnose_ID_Result, VDiagnose_dummy, 21);
            putValue(VSys_Analyse_SW, VDiagnose_ID_Result);
            putValue(VSys_Analyse_ID_Bar, getValue(VSys_Analyse_ID_Bar) + 10);            
            /* Request VAnalyse_ID_HW_STAND */
            DiagSendRequest(Act_Diagnose_Info_rq);
            break;

        case VAnalyse_ID_BOOTSW:
            /* Interpretation of VAnalyse_ID_DIAG_ID */
            strncpy(VDiagnose_ID_Result, "", 21);
            strncat(VDiagnose_ID_Result, "0x", 21);
            for(loop = 0x00; loop < 3 ; loop++)
            {
                if(VDiagnose_Bytes[3+loop] < 0x10)
                {
                    strncat(VDiagnose_ID_Result, "0", 21);
                }
                ltoa(VDiagnose_Bytes[3+loop], VDiagnose_dummy, 16);
                strncat(VDiagnose_ID_Result, VDiagnose_dummy, 21);
            }
            putValue(VSys_Analyse_Diag_ID, VDiagnose_ID_Result);
            putValue(VSys_Analyse_ID_Bar, getValue(VSys_Analyse_ID_Bar) + 10);            
            /* Request VAnalyse_ID_HW_STAND */
            DiagSendRequest(BOOT_Version_Read_rq);
            break;

        case VAnalyse_ID_END:
            /* Interpretation of VAnalyse_ID_BOOTSW */
            strncpy(VDiagnose_ID_Result, "", 21);
            ltoa(VDiagnose_Bytes[3], VDiagnose_ID_Result, 10);
            strncat(VDiagnose_ID_Result, "/", 21);
            ltoa(VDiagnose_Bytes[4], VDiagnose_dummy, 10);
            strncat(VDiagnose_ID_Result, VDiagnose_dummy, 21);
            strncat(VDiagnose_ID_Result,".", 21);
            ltoa(VDiagnose_Bytes[5], VDiagnose_dummy, 10);
            strncat(VDiagnose_ID_Result, VDiagnose_dummy, 21);
            putValue(VSys_Analyse_Bootloader, VDiagnose_ID_Result);
            putValue(VSys_Analyse_ID_Bar, getValue(VSys_Analyse_ID_Bar) + 10);
            VAnalyse_ID_Read_Status = RESET;
            break;

        default:
            VAnalyse_ID_Read_Status = RESET;
            break;
    }
}

/*--------------------------------------------------------------------------------------------------
Set Error-String for "Read out the identification datas"
Erstellt: 31.01.2012        Geändert: 31.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VAnalyse_ID_Set_Error ()
{
    putValue(VSys_Analyse_HW_Nb, "---");
    putValue(VSys_Analyse_HW, "---");
    putValue(VSys_Analyse_SW_Nb, "---");
    putValue(VSys_Analyse_SW, "---");
    putValue(VSys_Analyse_Diag_ID, "---");
    putValue(VSys_Analyse_Bootloader, "---");
}

/*--------------------------------------------------------------------------------------------------
Read out the identification datas
Erstellt: 31.01.2012        Geändert: 31.01.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_Analyse_ID_Read
{
    if(getValue(VSys_Analyse_ID_Read) == SET)
    {
        VAnalyse_ID_Set_Error();
        VAnalyse_ID_Read_Status = VAnalyse_ID_HW_NBR;
        putValue(VSys_Analyse_ID_Bar, RESET);
        VAnalyse_ID_Manager();
    }
}   

on diagResponse ActiveDiagnosticInformation_Read
{
    if(VAnalyse_ID_Read_Status == VAnalyse_ID_DIAG_ID)
    {
        VAnalyse_ID_Read_Status = VAnalyse_ID_BOOTSW;
        this.GetPrimitiveData (VDiagnose_Bytes, 40);
        VAnalyse_ID_Manager();
    }
}

on diagResponse BootSoftwareVersion_Read
{
    if(VAnalyse_ID_Read_Status == VAnalyse_ID_BOOTSW)
    {
        VAnalyse_ID_Read_Status = VAnalyse_ID_END;
        this.GetPrimitiveData (VDiagnose_Bytes, 40);
        VAnalyse_ID_Manager();
    }
}

on diagResponse HardwareVersion_Read
{
    if(VAnalyse_ID_Read_Status == VAnalyse_ID_HW_STAND)
    {
        VAnalyse_ID_Read_Status = VAnalyse_ID_SW_NBR;
        this.GetPrimitiveData (VDiagnose_Bytes, 40);
        VAnalyse_ID_Manager();
    }
}

on diagResponse MercedesCarGroupHardware_Read
{
    if(VAnalyse_ID_Read_Status == VAnalyse_ID_HW_NBR)
    {
        VAnalyse_ID_Read_Status = VAnalyse_ID_HW_STAND;
        this.GetPrimitiveData (VDiagnose_Bytes, 40);
        VAnalyse_ID_Manager();
    }
}

on diagResponse MercedesCarGroupSoftware_Read
{
    if(VAnalyse_ID_Read_Status == VAnalyse_ID_SW_NBR)
    {
        VAnalyse_ID_Read_Status = VAnalyse_ID_SW_STAND;
        this.GetPrimitiveData (VDiagnose_Bytes, 40);
        VAnalyse_ID_Manager();
    }
}

on diagResponse SoftwareVersion_Read
{
    if(VAnalyse_ID_Read_Status == VAnalyse_ID_SW_STAND)
    {
        VAnalyse_ID_Read_Status = VAnalyse_ID_DIAG_ID;
        this.GetPrimitiveData (VDiagnose_Bytes, 40);
        VAnalyse_ID_Manager();
    }
}

/*--------------------------------------------------------------------------------------------------
Reset-Timer für Auto-XCP
Erstellt: 01.02.2012        Geändert: 01.02.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer EnvXCPStart_Stop_DAQ_RESET_Timer
{
    putValue(EnvXCPStart_Stop_DAQ, RESET);
}

/*--------------------------------------------------------------------------------------------------
VS6 Start
Erstellt: 22.02.2012        Geändert: 13.06.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_VS6_Start_Button
{
        putValue(EnvXCPStart_Stop_DAQ, RESET);

        iRet = DiagSetTarget("ParkMan213");
        if(iRet != 0) 
           {
               write("!Fehler: DiagSetTarget (%d)!",iRet);
           }
       if(getValue(VSys_VS6_Start_Button) == SET)
        {
        DiagStartTesterPresent();
        DiagSendRequest(Extended_Start_service);  putValue(EnvXCPStart_Stop_DAQ, RESET);
        VSys_Start_Only_XCP_Manager();
        putValue(VSys_DevID_Write, 0x02);   //=> XCP-Data
        putValue(VSys_XCP_Mode_Write, 0x10);
      
        if(getValue(VSys_VS6_Status) == RESET)
        {
            /* TODO: Only temporary until diagnostics supports this */
            putValue(VSys_DevID_Status, 0x02);

            /* Set XCP-Data to P4U */
            if(getValue(VSys_DevID_Status) != 0x02)
            {
                putValue(VSys_DevID_Write, 0x02);   //=> XCP-Data
                putValue(VSys_XCP_Mode_Write, 0x10); //=> 360Grad
                putValue(VSys_DevID_Change_Rq, 0x01);
            }
            /* Start XCP */
            if(getValue(VSys_Msg_XCP_Rs_VARIABLE2_FR) != SET)
            {
                if(getValue(VSys_DevID_Status) != 0x02)
                {
                    cancelTimer(VSys_Start_XCP_Status_Timer);
                    setTimer(VSys_Start_XCP_Status_Timer, VSys_Start_XCP_Status_Timer_Timing);
                }
                else
                {
                    VSys_Start_XCP_Status = SET;
                    VSys_Send_Monitor_Function(MONITOR_FUNCTION_ACTIV);
                }   
            }
            /* WHL-Simulation => OFF */
            putValue(VSys_WHL_Status, RESET);
            /* Activation of Kombi-Sim */
            if(getValue(VSys_Real_Kombi) != SET)
            {
                putValue(VKombi_Status, SET);
            }
            /* VS6-Panel => Activation */
            putValue(Valeo_VS6switch, SET);
            /* !!!!!!!!! Attention: The status is important for "VSys_VS6_Status" */
            /* Start Timer */
            setTimer(VSys_V6_Start_Timer, VSYS_V6_START_TIMING);
        }
        else
        {
            cancelTimer(VSys_V6_Check_Timer);
            cancelTimer(VSys_V6_Start_Timer);
            putValue(VSys_VS6_Status, RESET);
        }
    }
}

/*--------------------------------------------------------------------------------------------------
Timer to check the change-conditions
Erstellt: 22.02.2012        Geändert: 22.02.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer VSys_V6_Start_Timer
{
    cancelTimer(VSys_V6_Start_Timer);

    putValue(VSys_DevID_Change_Rq, RESET);
    putValue(EnvXCPStart_Stop_DAQ, RESET);

    setTimerCyclic(VSys_V6_Check_Timer, VSys_V6_Check_Cycle);
    /* VS6-LED => ON */
    putValue(VSys_VS6_Status, SET);
}
/*--------------------------------------------------------------------------------------------------
Timer to Generate Key From Seed
Erstellt: 21.05.2014        Geändert:  
Erstellt: Y Lamsaddar      Geändert: 
---------------------------------------------------------------------------------------------------*/
on envVar  VSys_Set_Seed_Value
{
   
    if(getValue(VSys_Set_Seed_Value) == SET)
    {

      
      
      write("VSys_Seed_1Byte %lx",getValue(VSys_Seed_1Byte));
      write("VSys_Seed_2Byte %lx",getValue(VSys_Seed_2Byte));
      write("VSys_Seed_3Byte %lx",getValue(VSys_Seed_3Byte));
      write("VSys_Seed_4Byte %lx",getValue(VSys_Seed_4Byte));
      write("VSys_Seed_5Byte %lx",getValue(VSys_Seed_5Byte));
      write("VSys_Seed_6Byte %lx",getValue(VSys_Seed_6Byte));
      write("VSys_Seed_7Byte %lx",getValue(VSys_Seed_7Byte));
      write("VSys_Seed_8Byte %lx",getValue(VSys_Seed_8Byte));

    }
      
}
/*--------------------------------------------------------------------------------------------------
Timer to Generate Key From Seed
Erstellt: 21.05.2014        Geändert:  VSys_Key_1Byte
Erstellt: Y Lamsaddar      Geändert: 
---------------------------------------------------------------------------------------------------*/
on envVar  VSys_Key_Calc
{
   
    if(getValue(VSys_Key_Calc) == SET)
    {
   
            @VSys_Seed_1Byte =  gSeedArray[0];
            @VSys_Seed_2Byte =  gSeedArray[1];
            @VSys_Seed_3Byte =  gSeedArray[2];
            @VSys_Seed_4Byte =  gSeedArray[3];
            @VSys_Seed_5Byte =  gSeedArray[4];
            @VSys_Seed_6Byte =  gSeedArray[5];
            @VSys_Seed_7Byte =  gSeedArray[6];
            @VSys_Seed_8Byte =  gSeedArray[7];
            write("VSys_Seed_1Byte %lx",getValue(VSys_Seed_1Byte));
            write("VSys_Seed_2Byte %lx",getValue(VSys_Seed_2Byte));
            write("VSys_Seed_3Byte %lx",getValue(VSys_Seed_3Byte));
            write("VSys_Seed_4Byte %lx",getValue(VSys_Seed_4Byte));
            write("VSys_Seed_5Byte %lx",getValue(VSys_Seed_5Byte));
            write("VSys_Seed_6Byte %lx",getValue(VSys_Seed_6Byte));
            write("VSys_Seed_7Byte %lx",getValue(VSys_Seed_7Byte));
            write("VSys_Seed_8Byte %lx",getValue(VSys_Seed_8Byte));
          
      DiagGenerateKeyFromSeed (gSeedArray, gSeedArraySize, gSecurityLevel, gVariant, gOption, gKeyArray, gMaxKeyArraySize, gActualSize);
     @VSys_Key_1Byte = gKeyArray[0];
      write("VSys_Key_1Byte %lx---- %lx",getValue(VSys_Key_1Byte), gKeyArray[0]);
     @VSys_Key_2Byte = gKeyArray[1];
      write("VSys_Key_2Byte %lx",getValue(VSys_Key_2Byte));
     @VSys_Key_3Byte = gKeyArray[2];
      write("VSys_Key_3Byte %lx",getValue(VSys_Key_3Byte));
     @VSys_Key_4Byte = gKeyArray[3];
      write("VSys_Key_4Byte %lx",getValue(VSys_Key_4Byte));
     
    }
 
}
/*--------------------------------------------------------------------------------------------------
Timer to check the V6-Conditons
Erstellt: 22.02.2012        Geändert: 13.06.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer VSys_V6_Check_Timer
{
    result_l = SET;

    if(getValue(VSys_VS6_Status) == SET)
    {
        /* Set XCP-Data to P4U */
        if(getValue(VSys_DevID_Status) != 0x02) //if XCP-DATA == P4U
        {
            result_l = RESET;                
        }
        /* Send XCP */
        if(getValue(VSys_Msg_XCP_Rs_VARIABLE2_FR) != SET)
        {
            result_l = RESET;
        }
        /* WHL-Simulation => OFF */
        if(getValue(VSys_WHL_Status) != RESET)
        {
            result_l = RESET;
        }
        /* Activation of Kombi-Sim */
        if(getValue(VSys_Real_Kombi) != SET)
        {
            if(getValue(VKombi_Status) != SET)
            {
                result_l = RESET;
            }
        }
        /* VS6-Panel => Activation */
        if(getValue(Valeo_VS6switch) != SET)
        {
            result_l = RESET;
        }
        if(result_l == RESET)
        {
            cancelTimer(VSys_V6_Check_Timer);
//@JD            putValue(VSys_VS6_Status, RESET);
        }
    }
    else
    {
        cancelTimer(VSys_V6_Check_Timer);
    }
}

/*--------------------------------------------------------------------------------------------------
Initialization of the Diagnose_Panel after Measurement Start
Erstellt: 20.03.2012        Geändert: 20.03.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VDS_Init_At_Start ()
{
    putValue(VDS_Data0_0, RESET);
    putValue(VDS_Data0_1, RESET);
    putValue(VDS_Data0_2, RESET);
    putValue(VDS_Data0_3, RESET);
    putValue(VDS_Data0_4, RESET);
    putValue(VDS_Data0_5, RESET);
    putValue(VDS_Data0_6, RESET);
    putValue(VDS_Data0_7, RESET);
    putValue(VDS_Data1_0, RESET);
    putValue(VDS_Data1_1, RESET);
    putValue(VDS_Data1_2, RESET);
    putValue(VDS_Data1_3, RESET);
    putValue(VDS_Data1_4, RESET);
    putValue(VDS_Data1_5, RESET);
    putValue(VDS_Data1_6, RESET);
    putValue(VDS_Data1_7, RESET);

    putValue(VDS_Msg_Scroll, VDS_SUPPORTED_MSG);

    putValue(VDS_Msg_Nbr_0, 0x00);
    putValue(VDS_Msg_Nbr_1, 0x01);

    putValue(VDS_Msg_Act_0, RESET);
    putValue(VDS_Msg_Act_1, RESET);
}

/*--------------------------------------------------------------------------------------------------
Change Data_Timing
Erstellt: 23.03.2012        Geändert: 23.03.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_Data_Timing
{
    VDS_Data_Timing_Value[getValue(VDS_Msg_Nbr_0)] = getValue(VDS_Data_Timing);  
}

on envVar VDS_Sim_Start
{
    if(getValue(VDS_Sim_Start) == SET)
    {   
        putValue(VDS_Status_String, "!!! START SENDING !!!");
        VDS_Sending_Status = RESET;
        setTimer(VDS_Sending_Timer, 10);      
    }
}

/*--------------------------------------------------------------------------------------------------
Timer to Send the Diagnose_RQ_RS
Erstellt: 23.03.2012        Geändert: 23.03.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer VDS_Sending_Timer
{
    FrPDU DIAG_RQ_GLOBAL_1_FR msg_RQ_l;
    FrPDU DIAG_RS_PARK_FR msg_RS_l;
    byte message_typ_l;

    cancelTimer(VDS_Sending_Timer);
    
    if(VDS_Activation[VDS_Sending_Status] == SET)
    {
        message_typ_l = VDS_Msgs[VDS_Sending_Status]; 

        for(dummy_l = RESET; dummy_l < VDS_SUPPORTED_DATAS; dummy_l++)
        {
            if(message_typ_l == VDS_DIAG_RQ_GLOBAL_1_FR)
            {
                msg_RQ_l.BYTE(dummy_l) = VDS_Datas[VDS_Sending_Status][dummy_l];
            }
            else
            {
                msg_RS_l.BYTE(dummy_l) = VDS_Datas[VDS_Sending_Status][dummy_l];
            }
        }
        if(VDS_Msgs[VDS_Sending_Status] == VDS_DIAG_RQ_GLOBAL_1_FR)
            FRUpdatePDU(msg_RQ_l, 1, 1);
        else
            FRUpdatePDU(msg_RS_l, 1, 1);
        VDS_Sending_Status++;
        if(VDS_Sending_Status < VDS_SUPPORTED_MSG)
        {
            if(VDS_Activation[VDS_Sending_Status] == SET)
            {
                setTimer(VDS_Sending_Timer, VDS_Data_Timing_Value[VDS_Sending_Status-1]);
            }
            else
            {
                putValue(VDS_Status_String, "!!! FINISHED SENDING !!!");
            }
        }
        else
        {
            putValue(VDS_Status_String, "!!! FINISHED SENDING !!!");
        }
    }
    else
    {
        if(VDS_Sending_Status == RESET)
            putValue(VDS_Status_String, "!!! ERR: ACTIVATION MISSING !!!");        
        else
            putValue(VDS_Status_String, "!!! FINISHED SENDING !!!");
    }    
}

/*--------------------------------------------------------------------------------------------------
Will be called if the DIAG_RS_PARK_FR is received
Erstellt: 02.05.2012        Geändert: 28.09.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/
on frPDU DIAG_RS_PARK_FR
{
    if(VDiag_DevID_Status == SET)
    {
        if(
            (this.BYTE(0x08) == 0x6E) &&
            (this.BYTE(0x09) == 0xFD) &&
            (this.BYTE(0x0A) == 0x16)    
            )
        {
            VDiag_DevID_Status = RESET; 
            VSys_DevID_Read_Request();
        } 

        if(
            (this.BYTE(0x08) == 0x62) &&
            (this.BYTE(0x09) == 0xFD) &&
            (this.BYTE(0x0A) == 0x16)    
            )
        {
            if(
                ((this.BYTE(0x0B) & 0x0F) < 0x03) ||
                ((this.BYTE(0x0B) & 0x0F) == 0x0A)
            )
                putValue(VSys_DevID_Status, this.BYTE(0x0B) & 0x0F);
            else
            {
                putValue(VSys_DevID_Status, 0x03);
            }

            if(
                (((this.BYTE(0x0B) & 0xF0) >> 4) < 0x05) ||
                (((this.BYTE(0x0B) & 0xF0) >> 4) == 0x08) ||
                (((this.BYTE(0x0B) & 0xF0) >> 4) == 0x0A) ||
                (((this.BYTE(0x0B) & 0xF0) >> 4) == 0x0F)     
            )
            putValue(VSys_XCP_Mode_Status, this.BYTE(0x0B) & 0xF0);
            VDiag_DevID_Status = RESET; 
        } 
    }

    if(VSys_Start_XCP_Status == SET)
    {
        if(
            (this.BYTE(0x08) == 0x6E) &&
            (this.BYTE(0x09) == 0x03) &&
            (this.BYTE(0x0A) == 0x00)    
            )
        {
            VSys_Start_XCP_Status = RESET; 
            putValue(EnvXCPStart_Stop_DAQ, SET);
        } 
    }

    if(VSys_Start_Only_XCP != RESET)
    {
        if(
            (VSys_Start_Only_XCP == 0x01) &&
            (this.BYTE(0x08) == 0x50) &&
            (this.BYTE(0x09) == 0x03))
        {
            VSys_Start_Only_XCP_Manager();    
        }
        else
        {
            if(
            (VSys_Start_Only_XCP == 0x02) &&
            (this.BYTE(0x08) == 0x6E) &&
            (this.BYTE(0x09) == 0x03) &&
            (this.BYTE(0x0A) == 0x00))
            {
                VSys_Start_Only_XCP_Manager();
            }
        }        
    } 
    
    if(
        (this.BYTE(0x08) == 0x59) &&
        (this.BYTE(0x09) == 0x06) 
      )
    {
        if((this.BYTE(0x0D) & (0x01 << 0)) > 0x00)
        {
            putValue(VDS_EM_Status1, 0x01);    
        }        
        else
        {
            putValue(VDS_EM_Status1, 0x00);   
        }

        if((this.BYTE(0x0D) & (0x01 << 1)) > 0x00)
        {
            putValue(VDS_EM_Status2, 0x01);    
        }        
        else
        {
            putValue(VDS_EM_Status2, 0x00);   
        }

        if((this.BYTE(0x0D) & (0x01 << 2)) > 0x00)
        {
            putValue(VDS_EM_Status3, 0x01);    
        }        
        else
        {
            putValue(VDS_EM_Status3, 0x00);   
        }

        if((this.BYTE(0x0D) & (0x01 << 3)) > 0x00)
        {
            putValue(VDS_EM_Status4, 0x01);    
        }        
        else
        {
            putValue(VDS_EM_Status4, 0x00);   
        }

        if((this.BYTE(0x0D) & (0x01 << 4)) > 0x00)
        {
            putValue(VDS_EM_Status5, 0x01);    
        }        
        else
        {
            putValue(VDS_EM_Status5, 0x00);   
        }

        if((this.BYTE(0x0D) & (0x01 << 5)) > 0x00)
        {
            putValue(VDS_EM_Status6, 0x01);    
        }        
        else
        {
            putValue(VDS_EM_Status6, 0x00);   
        }

        if((this.BYTE(0x0D) & (0x01 << 6)) > 0x00)
        {
            putValue(VDS_EM_Status7, 0x01);    
        }        
        else
        {
            putValue(VDS_EM_Status7, 0x00);   
        }

        if((this.BYTE(0x0D) & (0x01 << 7)) > 0x00)
        {
            putValue(VDS_EM_Status8, 0x01);    
        }        
        else
        {
            putValue(VDS_EM_Status8, 0x00);   
        }
    }   
}

/*--------------------------------------------------------------------------------------------------
Send DevID Read Request
Erstellt: 02.05.2012        Geändert: 02.05.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_DevID_Read_Request ()
{
    FrPDU DIAG_RQ_GLOBAL_1_FR msg_RQ_l;

    for(loop = RESET; loop < 42; loop++)
    {
        msg_RQ_l.BYTE(loop) = RESET;
    }

    /* Initialisierung */
    msg_RQ_l.BYTE(0x00) = 0x74;
    msg_RQ_l.BYTE(0x01) = 0x30;
    msg_RQ_l.BYTE(0x02) = 0xEF;
    msg_RQ_l.BYTE(0x03) = 0x00;
    msg_RQ_l.BYTE(0x04) = 0x40;
    msg_RQ_l.BYTE(0x05) = 0x03;
    msg_RQ_l.BYTE(0x06) = 0x00;
    msg_RQ_l.BYTE(0x07) = 0x03;
    msg_RQ_l.BYTE(0x08) = 0x22;
    msg_RQ_l.BYTE(0x09) = 0xFD;
    msg_RQ_l.BYTE(0x0A) = 0x16;

    FRUpdatePDU(msg_RQ_l, 1, 1);
    VDiag_DevID_Status = SET;
}

on envVar CH_ESPWhlDir_FL_StatWhl_Lt_Stat_
{
  SetSignal(WhlDir_FL_Stat,@CH_ESPWhlDir_FL_StatWhl_Lt_Stat_);
}

on envVar CH_ESPWhlDir_FR_StatWhl_Rt_Stat_
{
  SetSignal(WhlDir_FR_Stat,@CH_ESPWhlDir_FR_StatWhl_Rt_Stat_);
}

on envVar CH_ESPWhlDir_RL_StatWhl_Lt_Stat_
{
  SetSignal(WhlDir_RL_Stat,@CH_ESPWhlDir_RL_StatWhl_Lt_Stat_);
}

on envVar CH_ESPWhlDir_RR_StatWhl_Rt_Stat_
{
  SetSignal(WhlDir_RR_Stat,@CH_ESPWhlDir_RR_StatWhl_Rt_Stat_);
}

on envVar CH_CPCTSL_Posn_ISMSBW_Stat_
{

  SetSignal(TSL_Posn_Target,@CH_CPCTSL_Posn_ISMSBW_Stat_);
  //SetSignal(Gr,@CH_CPC_Gr_Stat_);
}

/*--------------------------------------------------------------------------------------------------
Reaction of Real-Kombi-Change
Erstellt: 13.06.2012        Geändert: 13.06.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_Real_Kombi_Change
{
    if(getValue(VSys_Real_Kombi_Change) == SET)
    {
        if(getValue(VSys_Real_Kombi) ==  SET)
        {
            putValue(VSys_Real_Kombi, RESET);
        }
        else
        {
            putValue(VSys_Real_Kombi, SET);
            putValue(VKombi_Status, RESET);
        }
    }
}

on timer VSys_MoniF_Timer
{
    cancelTimer(VSys_MoniF_Timer);
    if(getValue(VSys_MoniF_Active) == SET)
    {
        if(VSys_MoniF_Failure_Occur == SET)
        {
            if(getValue(VSys_MoniF_Error_LED) == SET)
            {
                putValue(VSys_MoniF_Error_LED, RESET);
            }
            else
            {
                putValue(VSys_MoniF_Error_LED, SET);
            }
        }
        else
        {
            putValue(VSys_MoniF_Error_LED, RESET);
        }
        setTimer(VSys_MoniF_Timer, VSys_MoniF_Timing);
    }
}

on envVar VSys_MoniF_Active
{
    if(getValue(VSys_MoniF_Active) == SET)
    {
        cancelTimer(VSys_MoniF_Timer);
        setTimer(VSys_MoniF_Timer, VSys_MoniF_Timing);     
    }
}

on frPDU ROE_PARK
{
    if(getValue(VSys_MoniF_Active) == SET)
    {
        VSys_MoniF_Received_DTC = 0x00000000;
        VSys_MoniF_Received_DTC = VSys_MoniF_Received_DTC | ((this.ROE_DTC_PARK & 0xFF0000) >> 16);
        VSys_MoniF_Received_DTC = VSys_MoniF_Received_DTC | (this.ROE_DTC_PARK & 0x00FF00);
        VSys_MoniF_Received_DTC = VSys_MoniF_Received_DTC | ((this.ROE_DTC_PARK & 0x0000FF) << 16);
        VSys_MoniF_Received_DTC_Status = this.ROE_DTC_Stat_PARK;
        VSys_MoniF_Manager();
        if(getValue(VSys_MoniF_Write) == SET)
        {
            write("ROE %lx %x", VSys_MoniF_Received_DTC, VSys_MoniF_Received_DTC_Status);
        }
    }
}

VSys_MoniF_Manager ()
{
    VSys_MoniF_Result = RESET;    

    if(
        (VSys_MoniF_Received_DTC != VSys_MoniF_Received_DTC) || 
        (VSys_MoniF_Received_DTC_Status != VSys_MoniF_Received_Old_DTC_Status)
      )    
    {
        if((VSys_MoniF_Received_DTC_Status & 0x01) > RESET)
        {
            for(loop = RESET; loop < VSys_MoniF_Number_Of_DTCs; loop++)
            {
                if(VSys_MoniF_Received_DTC == VSys_MoniF_DTCs[loop])
                {      
                    VSys_MoniF_DTCs_Amount[loop] += 1;
                    VSys_MoniF_Result = SET;
                }
            }

            if(VSys_MoniF_Result == SET)
            {
                VSys_MoniF_Failure_Occur = SET;
                putValue(VSys_MoniF_Amount, getValue(VSys_MoniF_Amount) + 1);
            }
            else
            {
                VSys_MoniF_Failure_Occur = RESET;
            }
        }
        else
        {
            VSys_MoniF_Failure_Occur = RESET;
        }
    }

    VSys_MoniF_Received_Old_DTC = VSys_MoniF_Received_DTC;       
    VSys_MoniF_Received_Old_DTC_Status = VSys_MoniF_Received_DTC_Status;
}

/*--------------------------------------------------------------------------------------------------
Start Replay-Block
Erstellt: 26.07.2012        Geändert: 26.07.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VRepB_Stop
{
    if(getValue(VRepB_Status) == SET)
    {
        putValue(VRepB_Status, RESET);
        cancelTimer(VRepB_Check_Timer);
        if(-1 == ReplayState("Replay1"))
        {
          //  putValue(VRepB_Status_Text, "Replay-Block STOP");
        }
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for the check - if the replayblock is still running
Erstellt: 27.07.2012        Geändert: 27.07.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer VRepB_Check_Timer
{
    cancelTimer(VRepB_Check_Timer);
    if(ReplayState("Replay1") != REPLAYBLOCK_STATUS_START)
    {
        /* Replayblock is finish */
        //write("Replayblock is finish");
        if(getValue(VRepB_Option_Cyclic) == SET)
        {
            /* Replay AGAIN */
            //write("Replay-Again");
            ReplayStart("Replay1");
            setTimer(VRepB_Check_Timer, VRepB_Check_Timing+VRepB_Check_Timing_Again_Offset);
            putValue(VRepB_Test_Amount, getValue(VRepB_Test_Amount)+1);
        }
        else
        {
            /* Final Finished */
            putValue(VRepB_Status, RESET);
        }
    }
    else
    {
        setTimer(VRepB_Check_Timer, VRepB_Check_Timing);
    }
}

/*--------------------------------------------------------------------------------------------------
Start Replay-Block
Erstellt: 26.07.2012        Geändert: 26.07.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VRepB_Start
{
    if(getValue(VRepB_Status) == RESET)
    {
        putValue(VRepB_Status, SET);
        if(0x01 == ReplayStart("Replay1"))
        {
            cancelTimer(VRepB_Check_Timer);
            setTimer(VRepB_Check_Timer, VRepB_Check_Timing); 
            putValue(VRepB_Test_Amount, 0x01);
          //  putValue(VRepB_Status_Text, "Replay-Block is Running");
        }
       // else
           // putValue(VRepB_Status_Text, "Error during Starting");
    }
}

/*--------------------------------------------------------------------------------------------------
Start Read Distance 
Erstellt: 03.09.2012        Geändert: 03.09.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VAYS_Distance_Start
{
    if(getValue(VAYS_Distance_Start) == SET)
    {
        putValue(VAYS_Distance_Status, SET);

        cancelTimer(VAYS_Distance_Timer);
        setTimer(VAYS_Distance_Timer, getValue(VAYS_Distance_Cycle));
    }
}

/*--------------------------------------------------------------------------------------------------
Start Read Distance 
Erstellt: 03.09.2012        Geändert: 03.09.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VAYS_Distance_Stop
{
    if(getValue(VAYS_Distance_Stop) == SET)
    {
        putValue(VAYS_Distance_Status, RESET);
        VAYS_Distance_RQ = RESET;
        putValue(VAYS_Distance_FL_Disp, 0xFF);
        putValue(VAYS_Distance_FR_Disp, 0xFF);
        putValue(VAYS_Distance_RL_Disp, 0xFF);
        putValue(VAYS_Distance_RR_Disp, 0xFF);
        putValue(VAYS_Distance_FL, 0xFF);
        putValue(VAYS_Distance_FR, 0xFF);
        putValue(VAYS_Distance_RL, 0xFF);
        putValue(VAYS_Distance_RR, 0xFF); 
    }
}

/*--------------------------------------------------------------------------------------------------
Send Diagnostic Message (Read Distance)
Erstellt: 03.09.2012        Geändert: 03.09.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer VAYS_Distance_Timer
{
    FrPDU DIAG_RQ_GLOBAL_1_FR msg_RQ_l;
    
    cancelTimer(VAYS_Distance_Timer);

    if(getValue(VAYS_Distance_Status) == SET)
    {
        for(loop = RESET; loop < 42; loop++)
        {
            msg_RQ_l.BYTE(loop) = RESET;
        }

        /* Initialisierung */
        msg_RQ_l.BYTE(0x00) = 0x74;
        msg_RQ_l.BYTE(0x01) = 0x30;
        msg_RQ_l.BYTE(0x02) = 0xEF;
        msg_RQ_l.BYTE(0x03) = 0x00;
        msg_RQ_l.BYTE(0x04) = 0x40;
        msg_RQ_l.BYTE(0x05) = 0x03;
        msg_RQ_l.BYTE(0x06) = 0x00;
        msg_RQ_l.BYTE(0x07) = 0x03;
        msg_RQ_l.BYTE(0x08) = 0x22;
        msg_RQ_l.BYTE(0x09) = 0x02;
        msg_RQ_l.BYTE(0x0A) = 0x01;

        FRUpdatePDU(msg_RQ_l, 1, 1);

        VAYS_Distance_RQ = SET;
    }
}

/*--------------------------------------------------------------------------------------------------
Init BR212 W
Erstellt: 18.09.2012        Geändert: 18.09.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDTC_Init_BR212
{
    if(getValue(VDTC_Init_BR212) == SET)
    {
        setSignal(EVC_List0C_VehLine, VEH_LINE_212);
        setSignal(EVC_List02_BodyStyle, BODY_STYLE_FW);
    }
}

/*--------------------------------------------------------------------------------------------------
Init BR222 W
Erstellt: 18.09.2012        Geändert: 18.09.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDTC_Init_BR222
{
    if(getValue(VDTC_Init_BR222) == SET)
    {
        setSignal(EVC_List0C_VehLine, VEH_LINE_222);
        setSignal(EVC_List02_BodyStyle, BODY_STYLE_FW);
    }
}

/*--------------------------------------------------------------------------------------------------
Init BR251 R
Erstellt: 18.09.2012        Geändert: 18.09.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDTC_Init_BR251
{
    if(getValue(VDTC_Init_BR251) == SET)
    {
        setSignal(EVC_List0C_VehLine, 39);
        setSignal(EVC_List02_BodyStyle, BODY_STYLE_FR);
    }
}

/*--------------------------------------------------------------------------------------------------
Set Monitor-Function
Erstellt: 27.09.2012        Geändert: 27.09.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_Send_Monitor_Function(byte modus_p)
{
    FrPDU DIAG_RQ_GLOBAL_1_FR msg_RQ_l;

    if(modus_p == MONITOR_FUNCTION_ACTIV)
    {
        for(loop = RESET; loop < 42; loop++)
        {
            msg_RQ_l.BYTE(loop) = RESET;
        }

        /* Initialisierung */
        msg_RQ_l.BYTE(0x00) = 0x74;
        msg_RQ_l.BYTE(0x01) = 0x30;
        msg_RQ_l.BYTE(0x02) = 0xEF;
        msg_RQ_l.BYTE(0x03) = 0x00;
        msg_RQ_l.BYTE(0x04) = 0x40;
        msg_RQ_l.BYTE(0x05) = 0x04;
        msg_RQ_l.BYTE(0x06) = 0x00;
        msg_RQ_l.BYTE(0x07) = 0x04;
        msg_RQ_l.BYTE(0x08) = 0x2E;
        msg_RQ_l.BYTE(0x09) = 0x03;
        msg_RQ_l.BYTE(0x0A) = 0x00;
        msg_RQ_l.BYTE(0x0B) = 0x01;

        FRUpdatePDU(msg_RQ_l, 1, 1);

        VAYS_Distance_RQ = SET;
    }
}

on timer VSys_Start_XCP_Status_Timer
{
    cancelTimer(VSys_Start_XCP_Status_Timer);
    if(getValue(VSys_DevID_Status) != 0x02)
    {
        setTimer(VSys_Start_XCP_Status_Timer, VSys_Start_XCP_Status_Timer_Timing);
    }
    else
    {   
        /* Start XCP */
        VSys_Start_XCP_Status = SET;
        VSys_Send_Monitor_Function(MONITOR_FUNCTION_ACTIV);
    }
}

/*--------------------------------------------------------------------------------------------------
Pre-Initial all significant datas to avoid invalid datas 
Supported only the ecus ZGW, Mantelrohrmodul, EZS, Servo, ESP, Getriebe und Motor
Erstellt: 28.09.2012        Geändert: 01.10.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_PreInit ()
{
    
  
    // simulation of Raddrehzahl
      putValue(VSys_WHL_Change, SET);
    //CGW
    setSignal(Bckl_Sw_D_Stat, 0x01);
    setSignal(EVC_CfgBit_01_32_Stat, 0x01);
    setSignal(EVC_CfgList_01_0C_Stat, 0x01);
    setSignal(EVC_List01_StStyle, DEFAULT_STEERING);
    setSignal(EVC_List02_BodyStyle, BODY_STYLE_FW);
    setSignal(EVC_List05_TxStyle,  DEFAULT_TRANSMISSION_STYLE);
    setSignal(EVC_List08_Country, DEFAULT_COUNTRY);
    setSignal(EVC_List0C_VehLine, VEH_LINE_213);
    setSignal(EVC_CfgBit_97_C8_Stat, 0x01 ); 
    setSignal(AccelPdlPosn_Raw, 0x01 );
    setSignal(ParkSw_Psd, 0x00);
    //Mantelrohrmodul	
    setSignal(StWhl_Angl, 0x00);
    //EZS
    setSignal(DrRLtch_FL_Stat, 0x01); 
    setSignal(DrRLtch_FR_Stat, 0x01);
    setSignal(PN14_SupBat_Volt, 0);
    setSignal(RevGr_Engg, 0x01);
    setSignal(Trlr_Stat, 0x00);
    setSignal(IC_Err_Stat, 0x00);
    setSignal(IC_Func_Stat, 0x01);
    //setSignal(Park_DisclmDisp_Rs, 0x01);
    //setSignal(Park_DisclmDisp_Stat_IC, 0x01);
    setSignal(Park_IconDisp_Rs, 0x01);
    setSignal(Park_IconDisp_Stat_IC, 0x01);
    //setSignal(Park_MenuDisp_Rs, 0x01);
    //setSignal(Park_MenuDisp_Stat_IC, 0x01);
    //setSignal(Park_Proc_Stat_Rs, 0x01);
    setSignal(Park_Warn1_Disp_Rs, 0x01);
    setSignal(Park_Warn1_Disp_Stat_IC, 0x01);
    //setSignal(Park_Warn2_Disp_Rs, 0x01);
    //setSignal(Park_Warn2_Disp_Stat_IC, 0x01);
    //Servo	
    setSignal(PARK_Cancel_Stat, 0x02);   //I_C04_PARK_CANCEL_STAT_EPS_CANCEL
	  setSignal(PARK_Stat_EPS, 0x01);
	//setSignal(EPS_StRackPosn, 0x01);

    setSignal(EPS_FtWhlAngl_Offset, 0x80);
    setSignal(EPS_FtWhlAngl_Stat, 0x01);

    //ESP	
    setSignal(ESP_Sys_Stat_V2, 0x01); 
	/*setSignal(ESP_CtrlLmp_Info, 0x01); Deactivate otherwise VS6 is not working */
	  setSignal(VehYawRate_Raw, 0x01);
	  setSignal(SPCR_Sp_Stat, 0x00);        //I_C02_SPCR_SP_STAT_IDLE
	  setSignal(WhlDir_FL_Stat, 0x01);
	  setSignal(WhlDir_RL_Stat, 0x01);
	  setSignal(WhlRPM_FL, 0x01);
	  setSignal(WhlRPM_RL, 0x01);
	  setSignal(WhlDir_FR_Stat, 0x01);
	  setSignal(WhlDir_RR_Stat, 0x01);
	  setSignal(WhlRPM_FR, 0x01);
	  setSignal(WhlRPM_RR, 0x01);
	  setSignal(PARK_Brk_Stat_ESP, 0x01); 
    //Motor	
    setSignal(EngRun_Stat, 0x01);
    //Kombi
    setSignal(AirTemp_Outsd_Disp, 0x19);	
    setSignal(Odo, 0x01);	
    setSignal(VehSpd_Disp, 0x00);		
    setSignal(PTS_Disp_Stat_IC, 0x01);		
    //EBKB
    setSignal(ESP::EPKB_Stat_Gw_AR2::PkBrk_Stat, 0x01);		
    
  //EIS Config_HU_AR2 WarnElement 
  
     setSignal(Park_WarnFreq_Ft_Rq_HU, 0x02);
     setSignal(Park_WarnFreq_R_Rq_HU, 0x02);
     setSignal(Park_WarnVol_Ft_Rq_HU, 0x02);
     setSignal(Park_WarnVol_R_Rq_HU, 0x02); 
 
  // ESP WhlPls 
	setSignal( ESP::Whl_Rt_Stat_AR2::WhlPlsCnt_RR , 0x00); 
	setSignal(  ESP::Whl_Lt_Stat_AR2::WhlPlsCnt_RL , 0x00); 
	setSignal( ESP::Whl_Rt_Stat_AR2::WhlPlsCnt_FR , 0x00); 
	setSignal( ESP::Whl_Lt_Stat_AR2::WhlPlsCnt_FL , 0x00); 
  //APC
      setSignal(Park_APC_Sw_Psd_CTRL_L2 , 0x00); 
    	setSignal(Park_APC_Sw_Psd_CTRL_L , 0x03);
    	setSignal(Park_ParkSpaceSelSw_Psd_HU, 0x01); 
  //SVS
      setSignal(PARK_SysMd_Rq_HU , 0x00); 
    	setSignal(SVS_RevGrActvMd_Rq , 0x00);  
  //
  
    	setSignal(EIS::BSM_Disp_Warn_Rq_AR2::CTA_Brk_Rq, 0x00);        //I_C02_IDLE_PREFILL_ACTV_IDLE  
    	setSignal(EIS::BSM_Disp_Warn_Rq_AR2::CTA_Stat, 0x00);          //I_C02_INIT_RDY_FLT_INIT
    	setSignal(EIS::BSM_Disp_Warn_Rq_AR2::CTA_Warn_Lt_Rq, 0x00);     //I_C02_CTA_WARN_RQ_DSABL
      setSignal(EIS::BSM_Disp_Warn_Rq_AR2::CTA_Warn_Rt_Rq, 0x00);     //I_C02_CTA_WARN_RQ_DSABL  
    	setSignal(Park_Disp_Stat, 0x02);                                //I_C03_PARK_DISP_STAT_PM_SIG_NOT_ACTIVE
    	setSignal(PARK_BrkMd_Rs, 0x00);                                 //I_C02_PARK_BRKMD_RQ_COMF_STOP
    
      setSignal(PARK_Flt_Stat_ESP, 0x0d);                              //I_C05_PARK_FLT_STAT_ESP_ENG_OFF
    	setSignal(PARK_Impact_Stat, 0x00);                               //I_C04_PARK_IMPACT_STAT_IDLE
      setSignal(PPS_Cancel_Stat, 0x00);                                //I_C04_PPS_CANCEL_STAT_IDLE
    	setSignal(PARK_RemLocalPosn_Rq, 0x00);                           //
    	setSignal(SVS_ServMd_Rq, 0x00);                                  //I_C02_OFF_ON_OFF
      setSignal(VehAccel_X_V2, 0x02);
      setSignal(VehAccel_X_Offset, 0x80); 
  ////
      setSignal(Language_Rq_V2, 0);
      setSignal(PARK_BrkMd_Rs, 0);
      setSignal(RemPark_Stat_KG, 0);
      setSignal(PARK_Flt_Stat_ESP, 0);
      setSignal(PARK_Impact_Stat, 0);
      setSignal(PARK_Cancel_Stat, 0);
      setSignal(PPS_Cancel_Stat, 0);
      setSignal(PPS_Stat_EPS, 1);
      setSignal(RemPark_Stat_EIS, 1);
      setSignal(Park_RevGrMd_Rq_HU, 2);
      
      setSignal(Whl_Lt_Stat_AR2::WhlPlsCnt_FL, 0);
      @sysvar::CH_Nodes::CH__ESP_WhlPlsCnt_FL = 0;
      setSignal(Whl_Rt_Stat_AR2::WhlPlsCnt_FR, 0);
      @sysvar::CH_Nodes::CH__ESP_WhlPlsCnt_FR = 0;
      setSignal(Whl_Lt_Stat_AR2::WhlPlsCnt_RL, 0);
      @sysvar::CH_Nodes::CH__ESP_WhlPlsCnt_RL = 0;
      setSignal(Whl_Rt_Stat_AR2::WhlPlsCnt_RR, 0);
      @sysvar::CH_Nodes::CH__ESP_WhlPlsCnt_RR = 0;
      setSignal(SPCR_Sp_Stat,0);
      setSignal(PARK_Enbl_Stat_ESP, 0x01);                    //Enable APC
  
      setSignal (CT_Stat, 2);
      /* Date time Sigansl */
      getLocalTime(tm);

      setSignal(DateTmDay,tm[3]);
      setSignal(DateTmHour ,11);
      setSignal(DateTmMinute ,55);
      setSignal(DateTmMonth ,(tm[4]+1));
      setSignal(DateTmSecond ,00);
      setSignal(DateTmStat ,1);
      setSignal(DateTmYear ,(tm[5]-100 ));
  
      /* */
        setSignal(PARK_LDC_AfterrunCtrl_Actv ,0);
  /**/
  
    setSignal(Park_Sonar_Ft_Md_Rq_HU, 0x02);
    setSignal(Park_Sonar_R_Md_Rq_HU, 0x02);
    // LDC_DTR_STAT
    setSignal(LDC_DTR_Stat, 0x06); //I_C04_LDC_DTR_STAT_DTR_ON
    // BrkTrq_D_V2
    setSignal(BrkTrq_D_V2, 0x01); //not SNA
    // MirrFld_Stat_LHD 
    setSignal(MirrFld_Stat_LHD, 0x02);//DRIVE_POS
    // MirrFld_Stat_RHD
    setSignal(MirrFld_Stat_RHD, 0x02); //DRIVE_POS EVC_6B_MirrFld_Avl

    // EVC_6B_MirrFld_Avl
    setSignal(EVC_6B_MirrFld_Avl, 0x01); //DRIVE_POS 
  
    //Park_BrkMd_Rq_HU
    setSignal(Park_BrkMd_Rq_HU,0x02);     //I_C02_NDEF_OFF_ON_ON FOR PPB FROM HU Park_BrkMd_Rq_HU//
    //RemPark_Auth_Rs
    setSignal(RemPark_Auth_Rs,0x02);     //I_C02_AUTHZD_NOTAUTHZD_SNA_NDEF FOR RPA 
    //RemPark_Cancel_Stat_EIS
    setSignal(RemPark_Cancel_Stat_EIS,0x00); //I_C03_REMPARK_CANCEL_STAT_EIS_IDLE
    //Park_AttenuatMd_Rq_HU
    setSignal(Park_AttenuatMd_Rq_HU, 0x01); //I_CO2_OFF_ATTENUAT1_ATTENUAT2_ATTENUAT1
  
    ///default value of pdu  PDU LDC_SBW_Rq_SCCM_AR2
      setSignal(TSL_RND_Posn_StW ,0x06);     //I_C04_TSL_RND_POSN_STW_INI  
    //RemPark_Auth_Rs
    setSignal(TSL_P_Psd_StW,0x02);     //I_C02_TSL_P_PSD_STW_INI 
    //RemPark_Cancel_Stat_EIS
    setSignal(BrkFldIndLmp_On_Rq,0x00); // 
    //Park_AttenuatMd_Rq_HU
    setSignal(BrkLnWearIndLmp_On_Rq, 0x00); // 
    
    //VehSpd_X_Max
    setSignal(VehSpd_X_Max , 0x00); //  
  
    setSignal(BrkPdl_Stat , 0x00); //  BrkPdl_Stat
  //DAA_VCO_5825   
   setSignal(EF_Actv , 0x00); //
   setSignal(TurnInd_Lt_On , 0x00); //
   setSignal(TurnInd_Rt_On , 0x00); //
   setSignal(CPF_Ft_Stat , 0x00); //CPF_Ft_Stat 
   setSignal(ParkSw_Psd_CTRL_C , 0x00); //ParkSw_Psd_CTRL_C 
   setSignal(HU_On_Stat , 0x00); //ParkSw_Psd_CTRL_C 
  
  
   setSignal(TSL_RND_Posn_StW , 0x00); //ParkSw_Psd_CTRL_C 
  
  
} 
/*--------------------------------------------------------------------------------------------------
PARK_Enbl_Stat_ESP
Erstellt: 01.04.2015        Geändert: 08.08.2014
Erstellt: YL      Geändert: YL 
---------------------------------------------------------------------------------------------------*/

//on frpdu   RemPark_Rq_AR2
//{    
//      if ((getvalue(VSys_Rempark_Auth_Rs)==0x01) )  
//      {
//        if(getSignal(RemPark_Auth_Rq)==0x01 && (Rempark_Auth_Rs_Counter==0))
//        {
//            setSignal(RemPark_Auth_Rs,getValue(VSys_Sig_RemPark_Auth_Rs));
//            Rempark_Auth_Rs_Counter=1;
//          
//        }
//      }
//      else
//      {
//        setSignal(RemPark_Auth_Rs,getValue(VSys_Sig_RemPark_Auth_Rs));
//        write("------------VSys_Sig_RemPark_Auth_Rs--------%d------",RemPark_Auth_Rs);
//      }
//      
//     if(Rempark_Auth_Rs_Counter>=1)
//          {
//             Rempark_Auth_Rs_Counter ++;
//          }
//      if(Rempark_Auth_Rs_Counter > 601)
//      {
//        setSignal(RemPark_Auth_Rs,0x02);
//        Rempark_Auth_Rs_Counter = 0;
//      }
//}
/*--------------------------------------------------------------------------------------------------
PARK_Enbl_Stat_ESP
Erstellt: 08.08.2014        Geändert: 08.08.2014
Erstellt: YL      Geändert: YL 
---------------------------------------------------------------------------------------------------*/

on signal   PARK_Enbl_Stat_ESP
{
       putValue(VSys_PARK_Enbl_Stat_ESP,  getSignal(PARK_Enbl_Stat_ESP)); 
}
/*--------------------------------------------------------------------------------------------------
Start XCP
Erstellt: 03.09.2012        Geändert: 01.10.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_XCP_Start
{
    if(getValue(VSys_XCP_Start) == SET)
    {
        VSys_Start_Only_XCP = RESET;
        putValue(EnvXCPStart_Stop_DAQ, RESET);
        VSys_Start_Only_XCP_Manager();
    }
}

/*--------------------------------------------------------------------------------------------------
Set Change Session
Erstellt: 28.09.2012        Geändert: 28.09.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_Send_Change_Session(byte command_p)
{
    FrPDU DIAG_RQ_GLOBAL_1_FR msg_RQ_l;

    for(loop = RESET; loop < 42; loop++)
    {
        msg_RQ_l.BYTE(loop) = RESET;
    }

    /* Initialisierung */
    msg_RQ_l.BYTE(0x00) = 0x74;
    msg_RQ_l.BYTE(0x01) = 0x30;
    msg_RQ_l.BYTE(0x02) = 0xEF;
    msg_RQ_l.BYTE(0x03) = 0x00;
    msg_RQ_l.BYTE(0x04) = 0x40;
    msg_RQ_l.BYTE(0x05) = 0x02;
    msg_RQ_l.BYTE(0x06) = 0x00;
    msg_RQ_l.BYTE(0x07) = 0x02;
    msg_RQ_l.BYTE(0x08) = 0x10;
    msg_RQ_l.BYTE(0x09) = command_p;
    //write("------VSys_XCP_Start---%x---", command_p);

    FRUpdatePDU(msg_RQ_l, 1, 1);

    VAYS_Distance_RQ = SET;
}

/*--------------------------------------------------------------------------------------------------
Management Function for Identification Read
Erstellt: 28.09.2012        Geändert: 28.09.2012
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_Start_Only_XCP_Manager ()
{
    switch (VSys_Start_Only_XCP)
    {
        case 0x00:
            VSys_Send_Change_Session(DEFAULT_EXTENDED);
            VSys_Start_Only_XCP++;
            break;
        case 0x01:
            VSys_Send_Monitor_Function(MONITOR_FUNCTION_ACTIV);
            VSys_Start_Only_XCP++;
            break;
        case 0x02:
            putValue(EnvXCPStart_Stop_DAQ, SET);
            VSys_Start_Only_XCP = RESET;
            break;        
    }
}

on timer VSys_WHL_Update
{
    canceltimer(VSys_WHL_Update);

    if(
        (getValue(VSys_WHL_Status) != SET) &&
        (getValue(VSys_VS6_Status) != SET)
    )
    {
        $Whl_Lt_Stat_AR2::WhlPlsCnt_RL = @CH_Nodes::CH__ESP_WhlPlsCnt_RL;
        $Whl_Rt_Stat_AR2::WhlPlsCnt_RR = @CH_Nodes::CH__ESP_WhlPlsCnt_RR;
        $Whl_Lt_Stat_AR2::WhlPlsCnt_FL = @CH_Nodes::CH__ESP_WhlPlsCnt_FL;
        $Whl_Rt_Stat_AR2::WhlPlsCnt_FR = @CH_Nodes::CH__ESP_WhlPlsCnt_FR;    
    }

    setTimer(VSys_WHL_Update, VSys_WHL_Update_Timing);
}

/*--------------------------------------------------------------------------------------------------
Read out the identification datas
Erstellt: 22.01.2013        Geändert: 22.01.2013
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VSys_XCP_App_Car
{
    if(getValue(VSys_XCP_App_Car) == SET)
    {
        if(getValue(VSys_XCP_App_Car_Sts) == SET)
        {
            putValue(VSys_XCP_App_Car_Sts, RESET);        
        }
        else
        {
            putValue(VSys_XCP_App_Car_Sts, SET);
            putValue(VSys_XCP_Auto_Status, RESET); 
        }
    }
}

/*--------------------------------------------------------------------------------------------------
Timer for Auto XCP for Application on CAR
Erstellt: 22.01.2013        Geändert: 22.01.2013
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer VSys_XCP_App_Car_Timer
{
    cancelTimer(VSys_XCP_App_Car_Timer);

    /* Check if action is necessary */
    if(getValue(VSys_XCP_App_Car_Sts) == SET)
    {
        if(
            (getValue(VSys_XCP_Mode_Status) != XCP_MODE_360DEG) ||
            (getValue(VSys_DevID_Status) != XCP_DEVID_P4U_XCP) ||
            (getValue(VSys_Msg_XCP_Rs_VARIABLE2_FR) != SET)
          )
        {
            VSys_XCP_App_Car_Status = RESET;
            VSys_Start_XCP_APP_CAR();
            setTimer(VSys_XCP_App_Car_Timer,VSYS_XCP_APP_CAR_START_TIMING);
        }
        else
        {
            setTimer(VSys_XCP_App_Car_Timer,VSYS_XCP_APP_CAR_TIMING);
        }    
    }
    else
    {
        setTimer(VSys_XCP_App_Car_Timer,VSYS_XCP_APP_CAR_TIMING);
    }     
}

/*--------------------------------------------------------------------------------------------------
Start XCP_APP_CAR
Erstellt: 22.01.2013        Geändert: 22.01.2013
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

VSys_Start_XCP_APP_CAR ()
{
    /* Check if first call */
    if(VSys_XCP_App_Car_Status == RESET)
    {
        if(
            (getValue(VSys_XCP_Mode_Status) != XCP_MODE_360DEG) ||
            (getValue(VSys_DevID_Status) != XCP_DEVID_P4U_XCP) 
          )
        {
            VSys_XCP_App_Car_Status = 0x01;
        }
        else
        {
            VSys_XCP_App_Car_Status = 0x03;
        }      
    }

    switch(VSys_XCP_App_Car_Status)
    {
        case 0x01:
            /* Change XCP-Mode Part 1 */
            putValue(VSys_DevID_Write, XCP_DEVID_P4U_XCP);
            putValue(VSys_XCP_Mode_Write, XCP_MODE_360DEG);
            putValue(VSys_DevID_Change_Rq, 0x01);
            setTimer(VSys_XCP_App_Car_Start_Timer,10);
            VSys_XCP_App_Car_Status++;
            break;

        case 0x02:
            /* Change XCP-Mode Part 2*/
            putValue(VSys_DevID_Change_Rq, 0x00);
            setTimer(VSys_XCP_App_Car_Start_Timer,600);
            VSys_XCP_App_Car_Status++;
            break;

        case 0x03:
            /* Press Start-XCP-Button */ 
            putValue(VSys_XCP_Start, 0x01);
            setTimer(VSys_XCP_App_Car_Start_Timer,10);
            VSys_XCP_App_Car_Status++;   
            break;

        case 0x04:
            /* Press Start-XCP-Button */ 
            putValue(VSys_XCP_Start, 0x00);
            VSys_XCP_App_Car_Status = RESET;   
            break;

        default:
            VSys_XCP_App_Car_Status = RESET;
            break;
    }
}
/*--------------------------------------------------------------------------------------------------
Timer to set signal CLkS_Key_Rq_Raw to select for 500ms then idle
Erstellt: 23.07.2015        Geändert: 23.07.2015
Erstellt: Youssef Lamsaddar      Geändert: Youssef Lamsaddar
---------------------------------------------------------------------------------------------------*/
on envVar VSys_CLkS_Key_Rq_Raw_timer
{
	setTimer(VSys_CLkS_Key_Rq_Raw_timer,500);
  setSignal(CLkS_Key_Rq_Raw, 0x01 );
}
/*--------------------------------------------------------------------------------------------------
Timer to set signal CLkS_Key_Rq_Raw to select for 500ms then idle
Erstellt: 23.07.2015        Geändert: 23.07.2015
Erstellt: Youssef Lamsaddar      Geändert: Youssef Lamsaddar
---------------------------------------------------------------------------------------------------*/
on timer VSys_CLkS_Key_Rq_Raw_timer
{
	setSignal(CLkS_Key_Rq_Raw, 0x00 );
}
/*--------------------------------------------------------------------------------------------------
Timer to start Auto XCP for Application on CAR
Erstellt: 22.01.2013        Geändert: 22.01.2013
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on timer VSys_XCP_App_Car_Start_Timer
{
    canceltimer(VSys_XCP_App_Car_Start_Timer);
    VSys_Start_XCP_APP_CAR();
}

on envVar VBat_WE_Start
{
    if((getValue(VBat_WE_Start) == SET) && (VBAT_Status == 0))
    {
        VBAT_Status = 1;
        VBAT_Operation = VBAT_WE;
        VBat_WE_Manager();                    
    }
}

on timer VBAT_CHANGE_RESET_Timer
{
    cancelTimer(VBAT_CHANGE_RESET_Timer);
    putValue(VBat_Change, RESET); 
}

on timer VBAT_Timer
{
    cancelTimer(VBAT_Timer);
    switch(VBAT_Operation)
    {
        case VBAT_WE:
            VBat_WE_Manager();
            break;

        case VBAT_E3:
            VBat_E3_Manager();
            break;
    }    
}



VBat_WE_Manager()
{
    switch(VBAT_Status)
    {
        case 1:
            write("Preinitialition for Testing");
            setSignal(ISw_Stat, 0x00);
            putValue(VBat_Init, 0x01);
            setTimer(VBAT_Timer, 2000);
            VBAT_Status++;
            break;

        case 2:
            write("KLEMME 15");
            setSignal(ISw_Stat, 0x04);
            setTimer(VBAT_Timer, 1000);
            VBAT_Status++;
            break;

        case 3:
            write("Start Simulation WE-Problem");
            VBAT_Voltage_Before = getValue(VBat_Voltage);
            VBat_SetVoltage(getValue(VBat_WE_Voltage));
            setTimer(VBAT_Timer, 20);
            VBAT_Status++;
            break;

        case 4:
            VBat_SetVoltage(9.5);
            setTimer(VBAT_Timer, 400);
            VBAT_Status++;
            break;

        case 5:
            /* End Simulation */
            VBat_SetVoltage(VBAT_Voltage_Before);
            VBAT_Status = 0;
            break;
    
        default:
            VBAT_Status = 0;
            break;
    }    
}

VBat_SetVoltage(float voltage_p)
{
     putValue(VBat_Voltage, voltage_p);
     putValue(VBat_Change, SET);
     setTimer(VBAT_CHANGE_RESET_Timer, 1);    
}

VBat_E3_Manager()
{
    switch(VBAT_Status)
    {
        case 1:
            write("Start E3-Simulation");
            VBAT_Voltage_Before = getValue(VBat_Voltage);
            VBat_SetVoltage(getValue(VBat_E3_U3));
            setTimer(VBAT_Timer, 100);
            VBAT_Status++;
            break;

        case 2:
            VBat_SetVoltage(getValue(VBat_E3_U1));
            setTimer(VBAT_Timer, getValue(VBat_E3_T1));
            VBAT_Status++;
            break;

        case 3:
            VBat_SetVoltage(getValue(VBat_E3_U2));
            setTimer(VBAT_Timer, getValue(VBat_E3_T2));
            VBAT_Status++;
            break;

        case 4:
            VBat_SetVoltage(getValue(VBat_E3_U3));
            setTimer(VBAT_Timer,100);
            VBAT_Status++;
            break;

        case 5:
            /* END */
            VBat_SetVoltage(VBAT_Voltage_Before);
            VBAT_Status = 0;
            break;
    
        default:
            VBAT_Status = 0;
            break;
    }    
}

on envVar VBat_E3_Start
{
    if((getValue(VBat_E3_Start) == SET) && (VBAT_Status == 0))
    {
        VBAT_Status = 1;
        VBAT_Operation = VBAT_E3;
        VBat_E3_Manager();
    } 
}

VDS_EM_Send_Request (byte option_p)
{
    FrPDU DIAG_RQ_GLOBAL_1_FR msg_RQ_l;

    write("AABBCC");

    for(loop = RESET; loop < 42; loop++)
    {
        msg_RQ_l.BYTE(loop) = RESET;
    }

    switch(option_p)
    {
        case VDS_ERROR_MEMORY_DELETE_ALL:
            /* Initialisierung */
            msg_RQ_l.BYTE(0x00) = 0x74;
            msg_RQ_l.BYTE(0x01) = 0x30;
            msg_RQ_l.BYTE(0x02) = 0xEF;
            msg_RQ_l.BYTE(0x03) = 0x00;
            msg_RQ_l.BYTE(0x04) = 0x40;
            msg_RQ_l.BYTE(0x05) = 0x04;
            msg_RQ_l.BYTE(0x06) = 0x00;
            msg_RQ_l.BYTE(0x07) = 0x04;
            msg_RQ_l.BYTE(0x08) = 0x14;
            msg_RQ_l.BYTE(0x09) = 0xFF;
            msg_RQ_l.BYTE(0x0A) = 0xFF;
            msg_RQ_l.BYTE(0x0B) = 0xFF;
            break;            

        case VDS_ERROR_MEMORY_DELETE_SELECTED_DTC:
            /* Initialisierung */
            msg_RQ_l.BYTE(0x00) = 0x74;
            msg_RQ_l.BYTE(0x01) = 0x30;
            msg_RQ_l.BYTE(0x02) = 0xEF;
            msg_RQ_l.BYTE(0x03) = 0x00;
            msg_RQ_l.BYTE(0x04) = 0x40;
            msg_RQ_l.BYTE(0x05) = 0x04;
            msg_RQ_l.BYTE(0x06) = 0x00;
            msg_RQ_l.BYTE(0x07) = 0x04;
            msg_RQ_l.BYTE(0x08) = 0x14;
            msg_RQ_l.BYTE(0x09) = getValue(VDS_EM_DTC1);
            msg_RQ_l.BYTE(0x0A) = getValue(VDS_EM_DTC2);
            msg_RQ_l.BYTE(0x0B) = getValue(VDS_EM_DTC3);
            break;

        case VDS_ERROR_MEMORY_READ_STATUS:
            /* Initialisierung */
            msg_RQ_l.BYTE(0x00) = 0x74;
            msg_RQ_l.BYTE(0x01) = 0x30;
            msg_RQ_l.BYTE(0x02) = 0xEF;
            msg_RQ_l.BYTE(0x03) = 0x00;
            msg_RQ_l.BYTE(0x04) = 0x40;
            msg_RQ_l.BYTE(0x05) = 0x06;
            msg_RQ_l.BYTE(0x06) = 0x00;
            msg_RQ_l.BYTE(0x07) = 0x06;
            msg_RQ_l.BYTE(0x08) = 0x19;
            msg_RQ_l.BYTE(0x09) = 0x06;
            msg_RQ_l.BYTE(0x0A) = getValue(VDS_EM_DTC1);
            msg_RQ_l.BYTE(0x0B) = getValue(VDS_EM_DTC2);
            msg_RQ_l.BYTE(0x0C) = getValue(VDS_EM_DTC3);
            msg_RQ_l.BYTE(0x0D) = 0x01;
            break;

        default:
            break;
    }

    FRUpdatePDU(msg_RQ_l, 1, 1);
}

/*--------------------------------------------------------------------------------------------------
Error Memory Manager Option
Erstellt: 22.04.2013        Geändert: 22.04.2013
Erstellt: Markus Potok      Geändert: Markus Potok
---------------------------------------------------------------------------------------------------*/

on envVar VDS_EM_Options
{
    if((getValue(VDS_EM_Options) != RESET) && (getValue(VDS_EM_Options) <= 3))
    {
        VDS_EM_Send_Request (getValue(VDS_EM_Options));   
    }
}

