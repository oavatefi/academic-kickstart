/*@!Encoding:1252*/
variables {

//------------------ Serial Function buffer -----------------
int i;
long comPort;
char dataBlock[128];
byte dataBlock_byte[128];
char temp[128];
int receive=0;  				// RX counter
long numberOfChars;

float Volt = 0;     // Tankfüllstand wird als Sollspannung ausgewertet
float Volt_alt = 0;

// Anzusteuerndes Netzteil
const char Grundig = 1;
const char Toellner = 0;
char Netzteil = 0x02; 

int volt_1;  // Byte 3 of received message, represents the desired voltage before .
int volt_2;	 // Byte 4 of received message, represents the desired voltage before .
int mvolt_1; // Byte 5 of received message, represents the desired voltage behind .
int mvolt_2; // Byte 6 of received message, represents the desired voltage behind .

word voltage;
word voltage_1;
word voltage_2;
word voltage_3;
word voltage_4;

int temp_check;  // Byte 1
int temp_check1; // Byte 2

byte init_state;

mstimer inittimer;

}

on start
{
  putValue(VBat_Status, "NOT INIT"); 
}

print_chr(int addr,char chr)
{
int i;
byte ctrl,old;
byte ar[4];
int loopcount;

addr =0;   // 0x378;


for( loopcount =0 ; loopcount < 1000; ++loopcount)	//timeout beim Warten auf nicht busy
{
	ctrl=inport(addr+1);                   
	if(0x80==(ctrl&0x80))
	{
		//kein busy
 		write("%x",chr);
		outport(addr+0,chr);           // write char 
		ctrl = inport( addr + 2); 
		old=ctrl;
		ctrl = ctrl | 1;               // strobe on
		outport(addr+2,ctrl);         
		for(i=0;i<5;i++);              // small delay	//hb: evtl. länger warten
		outport(addr+2,old);           // strobe off
		break;
	}
}

if (loopcount==1000)
  write("Timeout always busy %x",chr);
}

Serial_function(byte init)
{ 
long baudRate;
long length;
long stop;
long useParity;
long modemControl;
long i;

  comPort=1;
  if(init==0)
    {
	  Rs232WriteByte(comPort,'#');    // will be send if key '#' is pressed
	} 
  if(init==1)
   {
     // Send TX Buffer to COM1

     //numberOfChars=getvalue(Serial_TX,dataBlock);
     
	 for(i=0;i<128;i++)					// Remember Panel is string and WriteBlock is byte
       dataBlock_byte[i]=dataBlock[i];
	 //write ("InitState %d, Port %d, Schreibe %s, Anzahl %d",init_state,comPort,dataBlock,numberOfChars);
     rs232Send(comPort,dataBlock_byte,numberOfChars); 
   }
  if(init==2)
   {
     // Modify adjustments from COM1 Parity Baudrate etc. 

     baudRate=9600;
	 length=1;
	 stop=0;
	 useParity=0;
	 write("Port %d Baudrate %d Datalength %d Stopbits %d Parity %d",comPort, baudRate,length,stop,useParity);
     rs232Open(comPort);
     rs232Configure(comPort, baudRate, length, stop, useParity);
	 Rs232SethandShake(1,4,0,0,0,0,-1); // DTR setzen

   }
}

RS232ByteCallback (long sendPort, long  byteData, long dirTag)
{
  // Rever to you manual for details !!
  int Spannung;

switch(dirTag)
 {
   case 2:
            //putvalue(Serial_RX,"RX Error reinit\n"); 
            break;   
   case 1:
            temp[receive++] = byteData;
			write ("Zeichen: %d, Anzahl %d",byteData,receive);
			if(byteData==0x0a)
			{
              Spannung = (temp[1]-48)*10+(temp[2]-48)+((float)temp[4]-48)/10+((float)temp[5]-48)/100;
			  write("Spannung: %g V",Spannung);
			  receive=0;
              for(i=0;i<128;i++)
               temp[i]=0;
			  
            }
			if(receive>=80)
             {
              write("RX Overflow too many character\n");  
              receive=0;
              for(i=0;i<128;i++)
               temp[i]=0;                 
             }
             else
             {
             // putvalue(Serial_RX,temp);
             } 
             break;
   case 0:
   		     //putvalue(Serial_RX,"RX Error default\n"); 
             break;
 }

}

PN300_init ()
{
  switch(init_state)
  {
      case 1:
          numberOfChars = 2;
          dataBlock[0] = 0x09;
          dataBlock[1] = 0x0A;// REN (Remote)
          Serial_function(1);
          settimer(inittimer, 100);
          break;

      case 2:
          numberOfChars = 5;
          Reset();
          settimer(inittimer, 100);
          break;

      case 3:
          numberOfChars = 6;
          dataBlock[0] = 0x53;
          dataBlock[1] = 0x45;
          dataBlock[2] = 0x4C;
          dataBlock[3] = 0x5F;
          dataBlock[4] = 0x41;
          dataBlock[5] = 0x0A;// SEL_A
          Serial_function(1);
          settimer(inittimer, 100);
          break;

      case 4:
          Strom_setzen (2,3,0,0);
          settimer(inittimer, 100);
          break;

      case 5:
          Spannung_setzen (1,2,0,0);
          settimer(inittimer, 100);
          break;

      case 6:
          Ausgang_ein ();
          putValue(VBat_Status, "Start Grundig");
          break;

      default:
          break;
  }
}

Spannung_setzen (word v1,word v2,word m1, word m2) // Spannungswert ist vierstellig ohne Komma,
{                                   // z.b. 1100 für 11,00 V
  if (Netzteil == Grundig)
  {
    numberOfChars = 11;
    dataBlock[0] = 0x56;
    dataBlock[1] = 0x53;
    dataBlock[2] = 0x45;
    dataBlock[3] = 0x54;// VSET
    dataBlock[4] = 0x20;// Blank
    dataBlock[5] = 0x30 + v1;
    dataBlock[6] = 0x30 + v2;
    dataBlock[7] = 0x2E;
    dataBlock[8] = 0x30 + m1;
    dataBlock[9] = 0x30 + m2;
    dataBlock[10] = 0x0A;// <lf>
    Serial_function(1);
  }
  if (Netzteil == Toellner)
  {
    numberOfChars = 8;
    dataBlock[0] = 0x56;// V
    dataBlock[1] = 0x20;// Blank
    dataBlock[2] = 0x30 + v1;
    dataBlock[3] = 0x30 + v2;
    dataBlock[4] = 0x2E;
    dataBlock[5] = 0x30 + m1;
    dataBlock[6] = 0x30 + m2;
    dataBlock[7] = 0x0A;// <lf>
    Serial_function(1);
  }
}

Strom_setzen (int a1, int ma1, int ma2, int ma3) 
{    
  byte j;                        
  if (Netzteil == Grundig)
  {
    numberOfChars = 11;
    dataBlock[0] = 0x49;
    dataBlock[1] = 0x53;
    dataBlock[2] = 0x45;
    dataBlock[3] = 0x54;// ISET
    dataBlock[4] = 0x20;// Blank
    j=4;
    }
  if (Netzteil == Toellner)
  {
    numberOfChars = 8;
    dataBlock[0] = 0x43;// C
    dataBlock[1] = 0x20;// Blank 
    j=1; 
   }
    dataBlock[++j] = 0x30 + a1;
    dataBlock[++j] = 0x2E;
    dataBlock[++j] = 0x30 + ma1;
    dataBlock[++j] = 0x30 + ma2;
    dataBlock[++j] = 0x30 + ma3;
    dataBlock[++j] = 0x0A;// <lf>
    Serial_function(1);
}

Ausgang_ein ()
{
  if (Netzteil == Grundig)
  {
    numberOfChars = 7;
    dataBlock[0] = 0x4F;
    dataBlock[1] = 0x55;
    dataBlock[2] = 0x54;
    dataBlock[3] = 0x5F;
    dataBlock[4] = 0x4F;
    dataBlock[5] = 0x4E;
    dataBlock[6] = 0x0A;// OUT_ON
    Serial_function(1);
    putValue(VBat_Status, "Start Grundig");
  }
  if (Netzteil == Toellner)
  {
    numberOfChars = 5;
    dataBlock[0] = 0x45;
    dataBlock[1] = 0x58;
    dataBlock[2] = 0x20;
    dataBlock[3] = 0x31;
    dataBlock[4] = 0x0A;// EX 1
    Serial_function(1);
    putValue(VBat_Status, "Start Toellner");
  }
}

Toellner_init()
{
  switch(init_state)
  {
      case 1: 
          numberOfChars = 9;
          dataBlock[0] = 0x53;
          dataBlock[1] = 0x59;
          dataBlock[2] = 0x53;
          dataBlock[3] = 0x54;
          dataBlock[4] = 0x3A;
          dataBlock[5] = 0x52;
          dataBlock[6] = 0x45;
          dataBlock[7] = 0x4D;
          dataBlock[8] = 0x0A;// SYST:REM (Remote)
          Serial_function(1);
          settimer(inittimer, 100);
          break;
  
      case 2:
          Reset();
          settimer(inittimer, 100);
          break;

      case 3:
          numberOfChars = 6;
          dataBlock[0] = 0x53;
          dataBlock[1] = 0x45;
          dataBlock[2] = 0x4C;
          dataBlock[3] = 0x20;
          dataBlock[4] = 0x31;
          dataBlock[5] = 0x0A;// SEL 1
          Serial_function(1);
          settimer(inittimer, 100);
          break;

      case 4:
          Strom_setzen (4,6,0,0);
          settimer(inittimer, 100);
          break;

      case 5:
          Spannung_setzen (1,2,0,0);
          settimer(inittimer, 100);
          break;

      case 6:
          Ausgang_ein ();
          putValue(VBat_Status, "Start Toellner");
          break;

      default:
          break;
  }
}

on timer inittimer
{
  init_state +=1;
  if (getValue(VBat_Power_Supplier) == Grundig)
  {
    PN300_init();		// Netzteil in Remote schalten etc.
  }
  if (getValue(VBat_Power_Supplier) == Toellner)
  {
    Toellner_init();
  }
  if(init_state == 6)
  {
    init_state = 0;
  }
}

Reset ()
{
  numberOfChars = 5;
  dataBlock[0] = 0x2A;
  dataBlock[1] = 0x52;
  dataBlock[2] = 0x53;
  dataBlock[3] = 0x54;
  dataBlock[4] = 0x0A;// *RST
  Serial_function(1);
}

on key 'r'
{
    Reset();
}

on key 'o'
{
    Ausgang_ein ();
}

on key 'f'
{
    Ausgang_aus ();
}

Ausgang_aus ()
{
  if (Netzteil == Grundig)
  {
    numberOfChars = 8;
    dataBlock[0] = 0x4F;
    dataBlock[1] = 0x55;
    dataBlock[2] = 0x54;
    dataBlock[3] = 0x5F;
    dataBlock[4] = 0x4F;
    dataBlock[5] = 0x46;
    dataBlock[6] = 0x46;
    dataBlock[7] = 0x0A;// OUT_ON
    Serial_function(1);
    putValue(VBat_Status, "Stop Grundig");
  }
  if (Netzteil == Toellner)
  {
    numberOfChars = 5;
    dataBlock[0] = 0x45;
    dataBlock[1] = 0x58;
    dataBlock[2] = 0x20;
    dataBlock[3] = 0x30;
    dataBlock[4] = 0x0A;// EX 0
    Serial_function(1);
    putValue(VBat_Status, "Stop Toellner");
  }
}

/*on message DiagReq_F1
{
	byte voltage;
	Volt=this.byte(1);	// Spannung übernehmen
	if (Volt!=Volt_alt && this.byte(0)==1)
	{		// Spannung hat sich geändert, Netzgerät neu einstellen
		Volt_alt = Volt;
		
		//Volt = (Volt-70)/2; // Umrechnung der Werte aus der Audi D4-Database

	    volt_1=Volt/10; //voltage digit 1
	    volt_2=Volt-10*volt_1; //voltage digit 2
	    mvolt_1=0;//voltage digit 3
	    mvolt_2=0;//voltage digit 4

		Volt = Volt_alt;

	    if ((10*volt_1+volt_2)>=0 & (10*volt_1+volt_2)<=20)
  	    {		// start voltage adjustment
            Spannung_setzen(volt_1, volt_2, mvolt_1, mvolt_2);
            write("Spannung = %d%d,%d%d V", volt_1, volt_2, mvolt_1, mvolt_2); 
        }
    }
}*/

on envVar VBat_Init
{
  if(getValue(VBat_Init) == 0x01)
  {
      Serial_function(2);
      if (getValue(VBat_Power_Supplier) == Grundig)
      {
        write("Init Grundig-Power-Supplier");
        init_state = 1;
        Netzteil = Grundig;
        PN300_init();	
      }
      if (getValue(VBat_Power_Supplier) == Toellner)
      {
        write("Init Toellner-Power-Supplier");
        init_state = 1;
        Netzteil = Toellner;
        Toellner_init();
      }
      putValue(VBat_Voltage, 12.0);
  }
}

on envVar VBat_ON
{
    if(getValue(VBat_ON) == 0x01)
    {
        Ausgang_ein ();    
    }
}

on envVar VBat_OFF
{
    if(getValue(VBat_OFF) == 0x01)
    {
        Ausgang_aus ();    
    }
}

on envVar VBat_Change
{
    if(getValue(VBat_Change) == 0x01)
    {
        if(
            (getValue(VBat_Voltage) >= 0) &&
            (getValue(VBat_Voltage) <= 19)
        )
        {
            voltage = getValue(VBat_Voltage)*100;
            voltage_1 = voltage/1000;
            voltage_2 = (voltage/100)%10;
            voltage_3 = (voltage/10)%10;
            voltage_4 = voltage%10;
            Spannung_setzen(voltage_1,voltage_2,voltage_3,voltage_4);    
        }      
    }
}

